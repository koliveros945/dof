<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<title>TI Retro: Robo de Capital $COP</title>
<style>
body{margin:0;background:#1b1b1b;color:#eee;font-family:monospace;display:flex;flex-direction:column;align-items:center;}
#ui-top{width:100%;max-width:650px;display:flex;align-items:center;gap:16px;padding:10px;background:#141414;border-bottom:1px solid #333;}
#portraits{display:flex;gap:8px;}
.portrait{width:50px;height:50px;background:#222;border:3px solid #444;border-radius:10px;display:flex;align-items:center;justify-content:center;cursor:pointer;overflow:hidden;}
.portrait img{width:100%; height:100%; object-fit:cover;}
.portrait.turn{border-color:#2d6cdf; box-shadow:0 0 10px rgba(45,108,223,.9)}
.portrait.active{border-color:#f39c12;}
#hp-panels{flex:1;display:flex;flex-direction:column;gap:6px;}
.hp-row{display:flex;align-items:center;gap:8px;}
.hp-row.active{background:rgba(243,156,18,0.2);border-radius:6px;padding:4px 6px;margin:-4px -6px;}
.hp-name{font-size:11px;min-width:75px;font-weight:bold;color:#aaa;}
.hp-row.active .hp-name{color:#f39c12;}
.hp-bar{flex:1;height:12px;background:#2a2a2a;border-radius:6px;overflow:hidden;border:1px solid #444;}
.hp-fill{height:100%;background:#2ecc71;transition:width 0.3s;}
.hp-fill.kevin{background:#f39c12;}
.hp-cop{font-size:11px;min-width:95px;text-align:right;font-weight:bold;color:#fff;}
#stats{min-width:140px;text-align:right;font-size:12px; font-weight:bold; color:#f39c12;}
#enemy-panels{display:flex;gap:8px;padding:8px;justify-content:center;width:100%;flex-wrap:wrap;}
.enemy-card{background:#111;border:2px solid #e74c3c;border-radius:8px;padding:6px 10px;min-width:130px;text-align:center;font-size:10px;transition:all 0.3s;}
.enemy-card.highlighted{border-color:#f39c12;box-shadow:0 0 15px rgba(243,156,18,0.8);transform:scale(1.05);}
.enemy-card.boss-card{border-color:#8e44ad;background:linear-gradient(180deg,#1a0a1a 0%,#2d1f3d 100%);min-width:180px;box-shadow:0 0 10px rgba(142,68,173,0.5);}
.cell.enemy-highlighted{box-shadow:inset 0 0 20px rgba(243,156,18,0.9);border:2px solid #f39c12 !important;}
#grid{display:grid;grid-template-columns:repeat(8,52px);grid-template-rows:repeat(8,52px);gap:4px;border:3px solid #333;padding:4px;background:#111;border-radius:8px;position:relative;image-rendering:pixelated;}

/* === ESCENARIO CALLE/CIUDAD (Nivel 1-2) === */
#grid.scene-street{
    background:
        linear-gradient(180deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
    border-color: #3d3d5c;
}
#grid.scene-street .cell{
    background:
        linear-gradient(135deg, #2d2d44 25%, transparent 25%),
        linear-gradient(225deg, #2d2d44 25%, transparent 25%),
        linear-gradient(45deg, #2d2d44 25%, transparent 25%),
        linear-gradient(315deg, #2d2d44 25%, #252540 25%);
    background-size: 26px 26px;
    background-position: 0 0, 13px 0, 13px -13px, 0px 13px;
    border: 1px solid #3d3d5c;
}
#grid.scene-street .wall{
    background:
        repeating-linear-gradient(0deg, #5c4033 0px, #5c4033 8px, #4a3429 8px, #4a3429 16px),
        repeating-linear-gradient(90deg, transparent 0px, transparent 24px, #3d2817 24px, #3d2817 26px);
    border: 2px solid #2a1a0a;
}

/* === ESCENARIO BANCO/B√ìVEDA (Nivel 3-4) === */
#grid.scene-bank{
    background:
        linear-gradient(180deg, #1a1a1a 0%, #2a2a2a 50%, #1f1f1f 100%);
    border-color: #c9a227;
    box-shadow: inset 0 0 20px rgba(201,162,39,0.3);
}
#grid.scene-bank .cell{
    background:
        linear-gradient(90deg, #2f2f2f 50%, #262626 50%);
    background-size: 13px 13px;
    border: 1px solid #444;
    box-shadow: inset 0 0 3px rgba(201,162,39,0.2);
}
#grid.scene-bank .wall{
    background:
        repeating-linear-gradient(90deg, #c9a227 0px, #c9a227 4px, #a8891f 4px, #a8891f 8px);
    border: 2px solid #8b7419;
    box-shadow: inset 0 0 8px rgba(0,0,0,0.5);
}

/* === ESCENARIO INFIERNO (Nivel 5 - Boss) === */
#grid.scene-hell{
    background:
        linear-gradient(180deg, #1a0000 0%, #330000 30%, #1a0000 70%, #0d0000 100%);
    border-color: #ff3300;
    box-shadow: 0 0 30px rgba(255,50,0,0.5), inset 0 0 30px rgba(255,0,0,0.3);
    animation: hell-glow 2s ease-in-out infinite;
}
@keyframes hell-glow {
    0%, 100% { box-shadow: 0 0 30px rgba(255,50,0,0.5), inset 0 0 30px rgba(255,0,0,0.3); }
    50% { box-shadow: 0 0 50px rgba(255,80,0,0.7), inset 0 0 40px rgba(255,30,0,0.5); }
}
#grid.scene-hell .cell{
    background:
        radial-gradient(circle at 50% 100%, #4a1a00 0%, #2a0a00 50%, #1a0000 100%);
    border: 1px solid #661a00;
    animation: lava-flicker 3s ease-in-out infinite;
}
@keyframes lava-flicker {
    0%, 100% { background: radial-gradient(circle at 50% 100%, #4a1a00 0%, #2a0a00 50%, #1a0000 100%); }
    33% { background: radial-gradient(circle at 30% 80%, #5a2000 0%, #3a1000 50%, #1a0000 100%); }
    66% { background: radial-gradient(circle at 70% 90%, #4a1500 0%, #2a0800 50%, #1a0000 100%); }
}
#grid.scene-hell .wall{
    background:
        linear-gradient(180deg, #1a1a1a 0%, #0a0a0a 50%, #1a1a1a 100%),
        repeating-linear-gradient(90deg, #333 0px, #333 4px, #222 4px, #222 8px);
    border: 2px solid #ff3300;
    box-shadow: 0 0 10px rgba(255,50,0,0.8);
}

.cell{width:52px;height:52px;background:#000;border:1px solid #2a5a2a;display:flex;align-items:center;justify-content:center;cursor:pointer;position:relative;}
.cell img{width:95%; height:95%; object-fit:contain; z-index:2; mix-blend-mode:screen;}
.cell img.diabla-sprite{width:80%; height:80%;}
.wall{background:#444;border-color:#222;cursor:default;}
.move{background:#2d6cdf !important; opacity:0.8;}
.spell{background:#f39c12 !important; opacity:0.8;}
.heal-zone{background:#ff69b4 !important; opacity:0.7;}
#spellbar{display:flex;gap:10px;background:#141414;padding:12px;border:1px solid #333;border-radius:12px;margin-bottom:10px;}
.spellBtn{padding:8px; min-width:105px; background:#222;border:2px solid #555;border-radius:8px;color:white;cursor:pointer;font-size:10px;font-weight:bold;}
.spellBtn:hover{border-color:#f39c12;}
.selected{border-color:#f39c12!important; background:#4d3b1a;}
#log{width:90%;max-width:650px;height:120px;overflow-y:auto;background:#000;border:1px solid #333;padding:8px;font-size:11px;color:#ccc;border-radius:8px;}
.log-dmg{color:#ff4d4d;}
.log-heal{color:#4dff4d;}
#end-overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.9);z-index:999;}
.hidden{display:none !important;}
/* Efecto de furia del Alem√°n */
@keyframes fury-pulse {
    0%, 100% { box-shadow: inset 0 0 15px rgba(255,0,0,0.8), 0 0 10px rgba(255,0,0,0.6); }
    50% { box-shadow: inset 0 0 25px rgba(255,80,0,1), 0 0 20px rgba(255,50,0,0.9); }
}
.cell.fury { animation: fury-pulse 0.5s ease-in-out infinite; border: 2px solid #ff3300 !important; }
.portrait.fury { animation: fury-pulse 0.5s ease-in-out infinite; border-color: #ff3300 !important; }
.hp-fill.fury { background: linear-gradient(90deg, #ff0000, #ff6600, #ff0000); background-size: 200% 100%; animation: fury-bar 0.5s linear infinite; }
@keyframes fury-bar { 0% { background-position: 0% 0%; } 100% { background-position: 200% 0%; } }

/* Efecto Ultra Instinto - para completar combo */
@keyframes ultra-instinct {
    0%, 100% {
        box-shadow: inset 0 0 20px rgba(200,220,255,0.9), 0 0 15px rgba(150,180,255,0.7), 0 0 30px rgba(100,150,255,0.5);
        filter: brightness(1.2) saturate(0.8);
    }
    50% {
        box-shadow: inset 0 0 30px rgba(255,255,255,1), 0 0 25px rgba(180,200,255,0.9), 0 0 40px rgba(150,180,255,0.7);
        filter: brightness(1.4) saturate(0.6);
    }
}
.cell.ultra-instinct {
    animation: ultra-instinct 0.8s ease-in-out infinite;
    border: 2px solid #c0d8ff !important;
}
.portrait.ultra-instinct {
    animation: ultra-instinct 0.8s ease-in-out infinite;
    border-color: #c0d8ff !important;
}
.spellBtn.ultra-instinct {
    animation: ultra-instinct 0.8s ease-in-out infinite;
    border-color: #c0d8ff !important;
    background: linear-gradient(135deg, #1a2a4a, #2a3a5a) !important;
}

/* Efecto Modo Escudo de H - azul brillante */
@keyframes shield-pulse {
    0%, 100% {
        box-shadow: inset 0 0 15px rgba(52,152,219,0.8), 0 0 12px rgba(41,128,185,0.7), 0 0 25px rgba(52,152,219,0.4);
        filter: brightness(1.1);
    }
    50% {
        box-shadow: inset 0 0 25px rgba(52,152,219,1), 0 0 20px rgba(41,128,185,0.9), 0 0 35px rgba(52,152,219,0.6);
        filter: brightness(1.3);
    }
}
.cell.shield-mode { animation: shield-pulse 0.7s ease-in-out infinite; border: 2px solid #3498db !important; }
.portrait.shield-mode { animation: shield-pulse 0.7s ease-in-out infinite; border-color: #3498db !important; }
.hp-fill.shield-mode { background: linear-gradient(90deg, #2980b9, #3498db, #2980b9); background-size: 200% 100%; animation: fury-bar 0.5s linear infinite; }

/* Efecto Uva Evolucionada - amarillo brillante */
@keyframes uva-evolved {
    0%, 100% {
        box-shadow: inset 0 0 15px rgba(241,196,15,0.8), 0 0 12px rgba(243,156,18,0.7), 0 0 25px rgba(241,196,15,0.4);
        filter: brightness(1.2) saturate(1.2);
    }
    50% {
        box-shadow: inset 0 0 25px rgba(241,196,15,1), 0 0 20px rgba(243,156,18,0.9), 0 0 35px rgba(241,196,15,0.6);
        filter: brightness(1.4) saturate(1.3);
    }
}
.cell.uva-evolved { animation: uva-evolved 0.6s ease-in-out infinite; border: 2px solid #f1c40f !important; }

/* Efecto Diabla - p√∫rpura demon√≠aco */
@keyframes diabla-pulse {
    0%, 100% {
        box-shadow: inset 0 0 15px rgba(142,68,173,0.8), 0 0 12px rgba(155,89,182,0.7), 0 0 25px rgba(142,68,173,0.4);
        filter: brightness(1.1);
    }
    50% {
        box-shadow: inset 0 0 25px rgba(192,57,43,1), 0 0 20px rgba(231,76,60,0.9), 0 0 35px rgba(192,57,43,0.6);
        filter: brightness(1.3);
    }
}
.cell.diabla-fury { animation: diabla-pulse 0.4s ease-in-out infinite; border: 2px solid #8e44ad !important; }

/* Efecto Fueguito - naranja parpadeante */
@keyframes fueguito-pulse {
    0%, 100% {
        box-shadow: inset 0 0 10px rgba(230,126,34,0.9), 0 0 8px rgba(211,84,0,0.7);
        filter: brightness(1.2);
    }
    50% {
        box-shadow: inset 0 0 18px rgba(241,196,15,1), 0 0 15px rgba(243,156,18,0.9);
        filter: brightness(1.4);
    }
}
.cell.fueguito { animation: fueguito-pulse 0.3s ease-in-out infinite; border: 2px solid #e67e22 !important; }

/* Efecto de fuego en casillas (ataque de ira) */
@keyframes fire-cell {
    0%, 100% {
        background: rgba(231,76,60,0.9);
        box-shadow: inset 0 0 20px rgba(255,100,0,0.8), 0 0 15px rgba(255,69,0,0.6);
    }
    25% {
        background: rgba(255,165,0,0.95);
        box-shadow: inset 0 0 30px rgba(255,200,0,1), 0 0 25px rgba(255,140,0,0.8);
    }
    50% {
        background: rgba(255,69,0,0.9);
        box-shadow: inset 0 0 25px rgba(255,50,0,0.9), 0 0 20px rgba(255,0,0,0.7);
    }
    75% {
        background: rgba(255,140,0,0.95);
        box-shadow: inset 0 0 30px rgba(255,180,0,1), 0 0 25px rgba(255,120,0,0.8);
    }
}
.cell.on-fire {
    animation: fire-cell 0.15s ease-in-out infinite;
    border: 2px solid #ff4500 !important;
    z-index: 10;
}

/* === PANELES LATERALES === */
#game-area {
    display: flex;
    align-items: flex-start;
    justify-content: center;
    gap: 15px;
    margin: 10px auto;
}
.side-panel {
    width: 180px;
    background: linear-gradient(180deg, #1a1a1a 0%, #0d0d0d 100%);
    border: 1px solid #333;
    border-radius: 10px;
    padding: 10px;
    font-size: 10px;
    color: #ccc;
}
.panel-title {
    font-size: 11px;
    font-weight: bold;
    color: #f39c12;
    text-align: center;
    padding: 5px;
    background: rgba(243,156,18,0.15);
    border-radius: 5px;
    margin-bottom: 8px;
}
.panel-section {
    display: flex;
    flex-direction: column;
    gap: 6px;
}
.rule-item, .passive-item, .tip-item {
    padding: 5px;
    background: rgba(255,255,255,0.03);
    border-radius: 4px;
    line-height: 1.3;
}
.char-tag {
    display: inline-block;
    padding: 1px 5px;
    border-radius: 3px;
    font-size: 9px;
    font-weight: bold;
    margin-right: 3px;
}
.char-tag.aleman { background: #c0392b; color: #fff; }
.char-tag.joven { background: #f39c12; color: #000; }
.char-tag.h-char { background: #3498db; color: #fff; }
.char-tag.uva-tag { background: #9b59b6; color: #fff; }
.combo-item {
    padding: 6px;
    background: rgba(255,255,255,0.05);
    border-radius: 5px;
    border-left: 3px solid #f39c12;
}
.combo-name {
    font-weight: bold;
    color: #fff;
    margin-bottom: 3px;
}
.combo-seq {
    color: #aaa;
    font-size: 9px;
    margin-bottom: 2px;
}
.combo-bonus {
    color: #2ecc71;
    font-weight: bold;
    font-size: 9px;
}
.tip-item {
    font-size: 9px;
    color: #aaa;
}
.tip-item b {
    color: #f39c12;
}
</style>
</head>
<body>

<div id="ui-top">
  <div id="portraits"></div>
  <div id="hp-panels"></div>
  <div id="stats">
    <div id="level-indicator" style="color:#f39c12; margin-bottom:4px;">NIVEL 1/5</div>
    PA: <span id="pa">6</span> | PM: <span id="pm">3</span>
  </div>
</div>

<div id="enemy-panels"></div>

<div id="game-area">
    <!-- Panel izquierdo: Reglas -->
    <div id="panel-left" class="side-panel">
        <div class="panel-title">üìú REGLAS</div>
        <div class="panel-section">
            <div class="rule-item">üíÄ Si <b>El Joven</b> llega a $0, pierdes la partida</div>
            <div class="rule-item">üéØ Elimina a todos los Escotes para ganar el nivel</div>
            <div class="rule-item">‚ö° PA = Puntos de Acci√≥n (hechizos)</div>
            <div class="rule-item">ü¶∂ PM = Puntos de Movimiento</div>
        </div>
        <div class="panel-title" style="margin-top:10px;">üî• PASIVAS</div>
        <div class="panel-section">
            <div class="passive-item"><span class="char-tag aleman">Alem√°n</span> <50% HP = x2 da√±o<br/><30% HP = x3 da√±o</div>
            <div class="passive-item"><span class="char-tag joven">Joven</span> M√°s HP = m√°s da√±o (hasta +50%)</div>
            <div class="passive-item"><span class="char-tag h-char">H</span> Aliado <35% HP = aura que da +30% resistencia a adyacentes</div>
            <div class="passive-item"><span class="char-tag uva-tag">Uva</span> Joven <30% HP = Uva evoluciona (nunca falla, ataque en cruz)</div>
        </div>
    </div>

    <!-- Tablero central -->
    <div id="grid"></div>

    <!-- Panel derecho: Combos -->
    <div id="panel-right" class="side-panel">
        <div class="panel-title">‚öîÔ∏è COMBOS</div>
        <div class="panel-section">
            <div class="combo-item">
                <div class="combo-name">ü•ä COMBO CL√ÅSICO</div>
                <div class="combo-seq">Empuj√≥n ‚Üí Atraco ‚Üí Pu√±o</div>
                <div class="combo-bonus">+1.5M da√±o puro (ignora resistencias)</div>
            </div>
            <div class="combo-item">
                <div class="combo-name">üí∞ COMBO LADR√ìN</div>
                <div class="combo-seq">Atraco ‚Üí Empuj√≥n ‚Üí Pu√±o</div>
                <div class="combo-bonus">+1.5M da√±o puro (ignora resistencias)</div>
            </div>
            <div class="combo-item">
                <div class="combo-name">üîó ATRACO EN CADENA</div>
                <div class="combo-seq">Diagonal ‚Üí Diagonal ‚Üí ...</div>
                <div class="combo-bonus">Golpea todos los enemigos en diagonal + intercambia pos.</div>
            </div>
        </div>
        <div class="panel-title" style="margin-top:10px;">üí° TIPS</div>
        <div class="panel-section">
            <div class="tip-item">‚Ä¢ Usa <b>Insulto</b> para debilitar enemigos (-PA y +da√±o recibido)</div>
            <div class="tip-item">‚Ä¢ <b>Cr√©dito</b> cura aliados adyacentes al Joven</div>
            <div class="tip-item">‚Ä¢ <b>Uva</b> puede boostear aliados o atacar enemigos</div>
            <div class="tip-item">‚Ä¢ Mant√©n a H cerca de aliados heridos para protegerlos</div>
        </div>
    </div>
</div>

<div id="spellbar">
    <div id="spells-inner" style="display:flex; gap:8px;"></div>
    <button id="endTurnBtn" style="padding:8px 15px; cursor:pointer; background:#e74c3c; color:white; border:none; border-radius:8px; font-weight:bold;">PASAR TURNO</button>
    <button id="muteBtn" onclick="toggleMute()" style="padding:8px 12px; cursor:pointer; background:#333; color:white; border:1px solid #555; border-radius:8px; font-size:16px;" title="Silenciar/Activar sonido">üîä</button>
</div>

<div id="log"></div>

<div id="end-overlay" class="hidden">
    <div style="background:#1b1b1b; padding:40px; border:2px solid #f39c12; text-align:center; border-radius:20px; max-width:400px;">
        <h2 id="end-title"></h2>
        <p id="end-msg"></p>
        <div id="end-buttons"></div>
    </div>
</div>

<script>
// ===== SISTEMA DE AUDIO =====
const AudioManager = {
    music: null,
    musicVolume: 0.4,
    sfxVolume: 0.6,
    muted: false,

    // Cargar y reproducir m√∫sica de nivel
    playMusic(level) {
        if(this.music) {
            this.music.pause();
            this.music.currentTime = 0;
        }
        this.music = new Audio(`nivel${level}.ogg`);
        this.music.loop = true;
        this.music.volume = this.muted ? 0 : this.musicVolume;
        this.music.play().catch(e => console.log('M√∫sica requiere interacci√≥n del usuario'));
    },

    // Reproducir efecto de sonido
    playSFX(name) {
        if(this.muted) return;
        const sfx = new Audio(`${name}.mp3`);
        sfx.volume = this.sfxVolume;
        sfx.play().catch(e => console.log('SFX no disponible:', name));
    },

    // Alternar mute
    toggleMute() {
        this.muted = !this.muted;
        if(this.music) {
            this.music.volume = this.muted ? 0 : this.musicVolume;
        }
        return this.muted;
    },

    // Detener m√∫sica
    stopMusic() {
        if(this.music) {
            this.music.pause();
            this.music.currentTime = 0;
        }
    },

    // Intentar reproducir m√∫sica (para despu√©s de interacci√≥n del usuario)
    tryPlayMusic() {
        if(this.music && this.music.paused) {
            this.music.play().catch(e => {});
        }
    }
};

// Iniciar m√∫sica con la primera interacci√≥n del usuario
let musicStarted = false;
function startMusicOnInteraction() {
    if(!musicStarted) {
        AudioManager.tryPlayMusic();
        musicStarted = true;
    }
}
document.addEventListener('click', startMusicOnInteraction, { once: false });
document.addEventListener('keydown', startMusicOnInteraction, { once: false });

// Mapeo de hechizos a efectos de sonido
const spellSFX = {
    'Pu√±o': 'puno',
    'Insulto': 'insulto',
    'Salto': 'salto',
    'Cargar': 'cargar',
    'Lanzar': 'lanzar',
    'Empujon': 'empujon',
    'Credito': 'credito',
    'Uva': 'uva',
    'Atraco': 'atraco',
    'Hola perdido!': 'hola_perdido',
    'Ya no saludas': 'ya_no_saludas',
    'Mordida üê∂': 'mordida',
    'critico': 'critico',
    'victoria': 'victoria',
    'derrota': 'derrota'
};

// ===== CONFIGURACI√ìN $COP =====
const fmt = (n) => new Intl.NumberFormat('es-CO', { style: 'currency', currency: 'COP', maximumFractionDigits: 0 }).format(n);
const SIZE = 8;
const MAX_LEVEL = 5;

// Sistema de niveles
let currentLevel = 1;
const levelConfig = {
    1: { enemies: 4, baseDmgMin: 451400, baseDmgMax: 633000, reward: 500000, enemyHp: 800000, enemyResist: 0.10 },
    2: { enemies: 5, baseDmgMin: 550000, baseDmgMax: 750000, reward: 750000, enemyHp: 1200000, enemyResist: 0.15 },
    3: { enemies: 6, baseDmgMin: 650000, baseDmgMax: 900000, reward: 1000000, enemyHp: 1800000, enemyResist: 0.20 },
    4: { enemies: 8, baseDmgMin: 800000, baseDmgMax: 1100000, reward: 1500000, enemyHp: 2500000, enemyResist: 0.25 },
    5: { enemies: 1, baseDmgMin: 900000, baseDmgMax: 1300000, reward: 0, enemyHp: 12000000, enemyResist: 0.30, isBoss: true }
};

// Fueguitos invocados por la Diabla
let fueguitos = [];

// HP base de los jugadores (todos iguales)
const baseHP = {
    'J': 1750905,
    'H': 1750905,
    'K': 1750905
};

let players = [
  {id:'J', name:'El Aleman', x:0,y:0, hp:1750905, maxHp:1750905, pa:6, pm:3, spells:['Pu√±o','Insulto','Salto'], carried:null},
  {id:'H', name:'H', x:0,y:0, hp:1750905, maxHp:1750905, pa:6, pm:3, spells:['Cargar','Lanzar','Empujon'], carried:null},
  {id:'K', name:'El Joven', x:0,y:0, hp:1750905, maxHp:1750905, pa:6, pm:3, spells:['Credito','Uva','Atraco'], carried:null}
];

let enemies = [];
let map = [];
let activeIdx = 0;
let uva = null;
let uvaUsed = false; // Solo se puede invocar una vez por combate
let enemyTurnActive = false;
let selectedSpell = null;
let isMoving = false;
let activeEffects = []; // Sistema de efectos temporales: {target, type, value, turnsLeft}
let highlightedEnemy = null; // Enemigo resaltado al hacer clic
let comboTracker = {}; // Trackea ataques recibidos por cada objetivo este turno: {targetId: [{spell, dmg}, ...]}

// ===== INICIALIZACI√ìN =====
function init(isNewLevel = false) {
    // Reproducir m√∫sica del nivel
    AudioManager.playMusic(currentLevel);

    // Generar mapa
    map = Array.from({length:SIZE}, (_,y) => Array.from({length:SIZE}, (_,x) => {
        if(x===0 || x===SIZE-1 || y===0 || y===SIZE-1) return 1;
        return Math.random() < 0.12 ? 1 : 0;
    }));

    // Reset de variables de combate
    enemies = [];
    uva = null;
    uvaUsed = false;
    enemyTurnActive = false;
    selectedSpell = null;
    isMoving = false;
    activeIdx = 0;
    activeEffects = [];
    turnCounter = 0;
    jovenAloneMessageShown = false;
    diablaComboTracker = {};

    // Posicionar jugadores y resetear PA/PM y limpiar buffs/debuffs
    players.forEach(p => {
        const pos = getEmptyPos();
        p.x = pos.x;
        p.y = pos.y;
        p.pa = 6;
        p.pm = 3;
        p.carried = null;
        // Limpiar todos los buffs/debuffs del combate anterior
        delete p.dmgBoost;
        delete p.resistance;
        delete p.vulnerability;
        // Si no es nivel nuevo, restaurar HP al m√°ximo
        if(!isNewLevel) {
            p.hp = p.maxHp;
        }
    });

    // Crear enemigos seg√∫n el nivel
    const config = levelConfig[currentLevel];
    fueguitos = []; // Limpiar fueguitos

    if(config.isBoss) {
        // NIVEL 5: BOSS - LA DIABLA
        const pos = getEmptyPos();
        enemies.push({
            id: 'DIABLA',
            name: 'üëø La Diabla',
            x: pos.x,
            y: pos.y,
            hp: config.enemyHp,
            maxHp: config.enemyHp,
            pa: 9,
            pm: 3,
            resistance: config.enemyResist,
            isBoss: true,
            lastIraUsed: -2, // Cooldown ataque de ira (cada 2 turnos)
            lastSueltameUsed: -3, // Cooldown "Sueltame!" (cada 3 turnos)
            lastGritoUsed: -4 // Cooldown "Grito" (cada 4 turnos)
        });
        log(`‚ïê‚ïê‚ïê NIVEL ${currentLevel}/${MAX_LEVEL} - BOSS FINAL ‚ïê‚ïê‚ïê`, 'log-dmg');
        log(`üëø ¬°LA DIABLA HA APARECIDO!`, 'log-dmg');
        log(`HP: ${fmt(config.enemyHp)} | Resistencia: ${Math.round(config.enemyResist*100)}%`);
        log(`¬°CUIDADO! Tiene 9 PA, ataque de ira e invoca fueguitos!`, 'log-dmg');
    } else {
        // Niveles normales: Escotes
        for(let i=0; i < config.enemies; i++) {
            const pos = getEmptyPos();
            enemies.push({
                id:'D'+i,
                name:'Escote '+(i+1),
                x:pos.x,
                y:pos.y,
                hp: config.enemyHp,
                maxHp: config.enemyHp * 5, // Pueden crecer hasta 5x robando
                pa:3,
                pm:2,
                resistance: config.enemyResist // Resistencia al da√±o
            });
        }
        log(`‚ïê‚ïê‚ïê NIVEL ${currentLevel}/${MAX_LEVEL} ‚ïê‚ïê‚ïê`, 'log-heal');
        log(`Escotes: ${config.enemies} | HP: ${fmt(config.enemyHp)} | Resistencia: ${Math.round(config.enemyResist*100)}%`);
        log(`Da√±o enemigo: ${fmt(config.baseDmgMin)}-${fmt(config.baseDmgMax)}`);
        log("¬°Los Escotes roban capital al atacar! Protege a El Joven.");
    }
    draw();
}

function getEmptyPos() {
    let x, y;
    do { x = Math.floor(Math.random()*SIZE); y = Math.floor(Math.random()*SIZE); } 
    while(map[y][x] === 1 || getEntityAt(x,y));
    return {x, y};
}

// Helper para identificar si una entidad es enemigo
function isEnemyEntity(ent) {
    if(!ent || !ent.id) return false;
    return ent.id.startsWith('D') || ent.id === 'DIABLA' || ent.id.startsWith('FUEGO');
}

function getEntityAt(x,y) {
    const p = players.find(pl => pl.x===x && pl.y===y && pl.hp > 0);
    if(p) return p;
    const e = enemies.find(en => en.x===x && en.y===y && en.hp > 0);
    if(e) return e;
    if(uva && uva.x===x && uva.y===y && uva.hp > 0) return uva;
    const f = fueguitos.find(fg => fg.x===x && fg.y===y);
    if(f) return f;
    return null;
}

// ===== PATHFINDING =====
function calculateReach(startX, startY, maxPM) {
    let reachable = new Map();
    let queue = [{x: startX, y: startY, dist: 0}];
    let visited = new Set([`${startX},${startY}`]);
    while(queue.length > 0) {
        let curr = queue.shift();
        if(curr.dist > 0) reachable.set(`${curr.x},${curr.y}`, curr.dist);
        if(curr.dist < maxPM) {
            for(let d of [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}]) {
                let nx=curr.x+d.x, ny=curr.y+d.y;
                if(nx>=0 && nx<SIZE && ny>=0 && ny<SIZE && !visited.has(`${nx},${ny}`) && map[ny][nx]===0 && !getEntityAt(nx,ny)) {
                    visited.add(`${nx},${ny}`); queue.push({x:nx, y:ny, dist:curr.dist+1});
                }
            }
        }
    }
    return reachable;
}

// ===== SISTEMA DE CR√çTICOS =====
const CRIT_CHANCE = 0.15; // 15% probabilidad de cr√≠tico
const CRIT_MULTIPLIER = 1.5; // 50% m√°s da√±o/efecto

function rollCrit() {
    return Math.random() < CRIT_CHANCE;
}

// ===== DA√ëO Y ROBO DE CAPITAL =====
function applyDamage(target, amount, spellName, attacker, ignoreResistance = false) {
    let finalDmg = amount;
    let isCrit = rollCrit();

    // Reproducir efecto de sonido del hechizo
    if(spellSFX[spellName]) {
        AudioManager.playSFX(spellSFX[spellName]);
    }

    // Golpe cr√≠tico: +50% da√±o
    if(isCrit) {
        finalDmg *= CRIT_MULTIPLIER;
        AudioManager.playSFX('critico');
        log(`üí• ¬°GOLPE CR√çTICO! +50% da√±o`, 'log-dmg');
    }

    // === HABILIDADES PASIVAS ===
    // El Alem√°n: m√°s da√±o cuando est√° bajo de vida
    // <30% = +200% (triple), 30-50% = +100% (doble)
    if(attacker.id === 'J') {
        const hpPercent = attacker.hp / attacker.maxHp;
        let passiveBonus = 0;
        let furyLevel = '';

        if(hpPercent < 0.30) {
            passiveBonus = 2.0; // <30% HP = +200% (triple da√±o)
            furyLevel = '¬°¬°FURIA EXTREMA!!';
        } else if(hpPercent < 0.50) {
            passiveBonus = 1.0; // 30-50% HP = +100% (doble da√±o)
            furyLevel = '¬°FURIA!';
        }

        if(passiveBonus > 0) {
            const bonus = finalDmg * passiveBonus;
            finalDmg += bonus;
            log(`üî• ${furyLevel}: +${Math.round(passiveBonus*100)}% da√±o (+${fmt(bonus)})`, 'log-heal');
        }
    }

    // El Joven: m√°s da√±o con m√°s vida (hasta +50% con 100% vida)
    if(attacker.id === 'K') {
        const hpPercent = attacker.hp / attacker.maxHp;
        const passiveBonus = hpPercent * 0.5; // 100% vida = +50%, 50% vida = +25%, 0% vida = +0%
        if(passiveBonus > 0.05) { // Solo mostrar si es significativo (>5%)
            const bonus = finalDmg * passiveBonus;
            finalDmg += bonus;
            log(`üí∞ Capital del Joven: +${Math.round(passiveBonus*100)}% da√±o (+${fmt(bonus)})`, 'log-heal');
        }
    }

    // Buff de da√±o del atacante (Pu√±o acumulable, Uva, etc.)
    if(attacker.dmgBoost) {
        const bonus = finalDmg * attacker.dmgBoost;
        finalDmg += bonus;
        log(`${attacker.name} tiene +${Math.round(attacker.dmgBoost*100)}% da√±o (+${fmt(bonus)})`, 'log-heal');
    }

    // Debuff de da√±o del atacante (acumulado por ataques de Diabla)
    if(attacker.dmgReduction) {
        const reduction = finalDmg * attacker.dmgReduction;
        finalDmg -= reduction;
        log(`üëø ${attacker.name} tiene -${Math.round(attacker.dmgReduction*100)}% da√±o (-${fmt(reduction)})`, 'log-dmg');
    }

    // Vulnerabilidad del objetivo (Insulto acumulable)
    if(target.vulnerability) {
        const extra = finalDmg * target.vulnerability;
        finalDmg += extra;
        log(`${target.name} es vulnerable: +${Math.round(target.vulnerability*100)}% da√±o recibido (+${fmt(extra)})`, 'log-dmg');
    }

    // Resistencia (reducen da√±o recibido) - ignorada en da√±o por colisi√≥n
    if(target.resistance && !ignoreResistance) {
        const reduced = finalDmg * target.resistance;
        finalDmg -= reduced;
        log(`${target.name} resiste ${Math.round(target.resistance*100)}% (-${fmt(reduced)})`, 'log-heal');
    }

    target.hp -= finalDmg;

    // REGLA: Escotes roban todo, Diabla roba la mitad
    if(attacker.id.startsWith('D') && attacker.id !== 'DIABLA') {
        attacker.hp = Math.min(attacker.maxHp, attacker.hp + finalDmg);
        log(`${attacker.name} rob√≥ ${fmt(finalDmg)} y aument√≥ su saldo.`, 'log-heal');
    } else if(attacker.id === 'DIABLA') {
        const stolen = finalDmg * 0.5;
        attacker.hp = Math.min(attacker.maxHp, attacker.hp + stolen);
        log(`${attacker.name} rob√≥ ${fmt(stolen)} (50%) y aument√≥ su saldo.`, 'log-heal');

        // Diabla reduce el da√±o del objetivo 2-10% por 4 turnos (acumulable)
        const debuffAmount = 0.02 + Math.random() * 0.08; // 2-10%
        addEffect(target, 'dmgReduction', debuffAmount, 4);
        log(`üëø ${target.name} tiene -${Math.round(debuffAmount*100)}% da√±o por 4 turnos!`, 'log-dmg');
    }

    log(`${attacker.name} usa "${spellName}". ${target.name} pierde ${fmt(finalDmg)}${isCrit ? ' üí•' : ''}`, 'log-dmg');

    // Trackear ataque para sistema de combos (solo ataques de jugadores)
    // Normalizar nombre del hechizo para el combo
    let comboSpell = spellName;
    if(spellName.startsWith('Empujon')) comboSpell = 'Empujon';

    if(attacker && !attacker.id.includes('D') && ['Empujon', 'Atraco', 'Pu√±o'].includes(comboSpell)) {
        if(!comboTracker[target.id]) comboTracker[target.id] = [];
        comboTracker[target.id].push({ spell: comboSpell, dmg: finalDmg });
        checkAndApplyCombo(target);
        notifyComboProgress(target.id);
    }

    if(target.hp <= 0) {
        target.hp = 0;
        if(target.id === 'K') endGame("QUIEBRA DEL JOVEN", "El saldo de El Joven es $0. Has perdido.", false);
        else if(isEnemyEntity(target)) {
            log(`${target.name} fue liquidado.`);
            enemies = enemies.filter(e => e.hp > 0);
            if(enemies.length === 0) endGame("¬°VICTORIA!", "Escotes eliminados. Capital a salvo.", true);
        } else if(target.id === 'U') {
            log("Uva üê∂ se ha ido."); uva = null;
        }
    }
}

// Sistema de combos: verifica si se complet√≥ un combo y aplica da√±o bonus
function checkAndApplyCombo(target) {
    const hits = comboTracker[target.id];
    if(!hits || hits.length < 3) return;

    // Buscar las √∫ltimas 3 secuencias
    const last3 = hits.slice(-3);
    const sequence = last3.map(h => h.spell).join('+');

    // Combo 1: Empujon + Atraco + Pu√±o
    // Combo 2: Atraco + Empujon + Pu√±o
    if(sequence === 'Empujon+Atraco+Pu√±o' || sequence === 'Atraco+Empujon+Pu√±o') {
        // Da√±o bonus FIJO de 1,500,000 que IGNORA resistencias
        const bonusDmg = 1500000;

        target.hp -= bonusDmg;
        log(`üí•üí•üí• ¬°¬°COMBO DEVASTADOR!! ${target.name} recibe ${fmt(bonusDmg)} de da√±o PURO adicional!`, 'log-dmg');
        AudioManager.playSFX('critico');

        // Limpiar el combo tracker para este objetivo (no se puede repetir inmediatamente)
        comboTracker[target.id] = [];

        // Verificar si muri√≥
        if(target.hp <= 0) {
            target.hp = 0;
            if(isEnemyEntity(target)) {
                log(`${target.name} fue ANIQUILADO por el combo!`);
                enemies = enemies.filter(e => e.hp > 0);
                if(enemies.length === 0) endGame("¬°VICTORIA!", "Escotes eliminados. Capital a salvo.", true);
            }
        }
    }
}

// Detecta si hay un combo pendiente y qu√© hechizo lo completar√≠a
function getComboFinisher() {
    // Buscar en todos los enemigos si alguno tiene 2 hits del combo
    for(const targetId in comboTracker) {
        const hits = comboTracker[targetId];
        if(!hits || hits.length < 2) continue;

        const last2 = hits.slice(-2).map(h => h.spell).join('+');

        // Combo 1: Empujon + Atraco + ? ‚Üí necesita Pu√±o
        if(last2 === 'Empujon+Atraco') return { finisher: 'Pu√±o', targetId };
        // Combo 2: Atraco + Empujon + ? ‚Üí necesita Pu√±o
        if(last2 === 'Atraco+Empujon') return { finisher: 'Pu√±o', targetId };
    }
    return null;
}

// Notifica al usuario sobre el progreso del combo
function notifyComboProgress(targetId) {
    const hits = comboTracker[targetId];
    if(!hits || hits.length < 1) return;

    const target = enemies.find(e => e.id === targetId);
    if(!target) return;

    const last1 = hits.slice(-1).map(h => h.spell).join('');
    const last2 = hits.length >= 2 ? hits.slice(-2).map(h => h.spell).join('+') : '';

    // Notificar inicio de combo
    if(hits.length === 1 && (last1 === 'Empujon' || last1 === 'Atraco')) {
        log(`‚ö° COMBO INICIADO en ${target.name}: ${last1} ‚Üí necesita ${last1 === 'Empujon' ? 'Atraco' : 'Empujon'} + Pu√±o`, 'log-heal');
    }
    // Notificar que falta el finisher
    else if(last2 === 'Empujon+Atraco' || last2 === 'Atraco+Empujon') {
        log(`‚ö°‚ö° ¬°COMBO LISTO! ${target.name} est√° vulnerable. ¬°El Alem√°n puede rematar con PU√ëO!`, 'log-heal');
    }
}

// ===== DIBUJO =====
function draw() {
    const grid = document.getElementById('grid');
    grid.innerHTML = '';

    // Aplicar escenario seg√∫n nivel
    grid.classList.remove('scene-street', 'scene-bank', 'scene-hell');
    if(currentLevel <= 2) {
        grid.classList.add('scene-street');
    } else if(currentLevel <= 4) {
        grid.classList.add('scene-bank');
    } else {
        grid.classList.add('scene-hell');
    }

    const p = players[activeIdx];
    let reachMap = isMoving ? calculateReach(p.x, p.y, p.pm) : new Map();

    // Detectar si hay combo pendiente
    const comboInfo = getComboFinisher();

    for(let y=0; y<SIZE; y++) {
        for(let x=0; x<SIZE; x++) {
            const cell = document.createElement('div');
            cell.className = 'cell' + (map[y][x]===1 ? ' wall' : '');
            const ent = getEntityAt(x,y);
            if(ent) {
                const img = document.createElement('img');
                if(ent.id === 'J') img.src = 'aleman.png';
                else if(ent.id === 'H') img.src = 'h.png';
                else if(ent.id === 'K') img.src = 'joven.png';
                else if(ent.id === 'DIABLA') { img.src = 'diabla.png'; img.classList.add('diabla-sprite'); }
                else if(ent.id && ent.id.startsWith('FUEGO')) img.src = 'fuego.png';
                else if(ent.id && ent.id.includes('D')) img.src = 'escote.png';
                else if(ent.id === 'U') img.src = 'uva.png';
                cell.appendChild(img);
                // Resaltar enemigo seleccionado en el tablero
                if(ent.id === highlightedEnemy) {
                    cell.classList.add('enemy-highlighted');
                }
                // Efecto de furia del Alem√°n (< 50% vida)
                if(ent.id === 'J' && ent.hp / ent.maxHp < 0.50) {
                    cell.classList.add('fury');
                }
                // Efecto Ultra Instinto - Alem√°n puede completar combo con Pu√±o
                if(comboInfo && comboInfo.finisher === 'Pu√±o' && ent.id === 'J' && ent.hp > 0) {
                    cell.classList.add('ultra-instinct');
                }
                // Efecto Modo Escudo de H (alg√∫n aliado < 35% vida)
                const anyAllyLowHP = players.some(ally => ally.hp > 0 && (ally.hp / ally.maxHp) < 0.35);
                if(ent.id === 'H' && anyAllyLowHP) {
                    cell.classList.add('shield-mode');
                }
                // Efecto Uva Evolucionada (Joven < 30% vida)
                const joven = players.find(pl => pl.id === 'K');
                if(ent.id === 'U' && uva && joven && joven.hp / joven.maxHp < 0.30) {
                    cell.classList.add('uva-evolved');
                }
                // Efecto de furia de la Diabla (< 30% vida)
                if(ent.id === 'DIABLA' && ent.hp / ent.maxHp < 0.30) {
                    cell.classList.add('diabla-fury');
                }
                // Efecto fueguito
                if(ent.id && ent.id.startsWith('FUEGO')) {
                    cell.classList.add('fueguito');
                }
            }
            if(isMoving && reachMap.has(`${x},${y}`)) cell.classList.add('move');
            if(selectedSpell && checkSpellRange(x,y)) cell.classList.add('spell');
            // Mostrar zona de curaci√≥n rosada para Cr√©dito
            if(selectedSpell === 'Credito') {
                const kevin = players.find(pl => pl.id === 'K');
                if(kevin && Math.abs(kevin.x - x) + Math.abs(kevin.y - y) <= 1) {
                    cell.classList.add('heal-zone');
                }
            }
            cell.onclick = () => onCellClick(x,y, reachMap.get(`${x},${y}`));
            grid.appendChild(cell);
        }
    }
    updateUI();
}

function updateUI() {
    const p = players[activeIdx];
    document.getElementById('pa').textContent = p.pa;
    document.getElementById('pm').textContent = p.pm;
    document.getElementById('level-indicator').textContent = `NIVEL ${currentLevel}/${MAX_LEVEL}`;

    // Renderizar barras de HP de todos los jugadores
    const hpPanels = document.getElementById('hp-panels');
    hpPanels.innerHTML = '';
    players.forEach((pl, i) => {
        if(pl.hp <= 0) return;
        const row = document.createElement('div');
        row.className = `hp-row ${i === activeIdx ? 'active' : ''}`;
        const pct = Math.max(0, (pl.hp / pl.maxHp) * 100);
        // Mostrar buffs/debuffs activos
        let buffs = '';
        if(pl.dmgBoost) buffs += `<span style="color:#4dff4d;">+${Math.round(pl.dmgBoost*100)}%DMG</span> `;
        if(pl.resistance) buffs += `<span style="color:#3498db;">+${Math.round(pl.resistance*100)}%RES</span> `;
        if(pl.vulnerability) buffs += `<span style="color:#e74c3c;">-${Math.round(pl.vulnerability*100)}%DEF</span> `;

        // Clase especial para Alem√°n en furia (activa desde 50% HP)
        const isFury = pl.id === 'J' && pct < 50;
        // Clase especial para H en modo escudo (aliado < 35%)
        const anyAllyLow = players.some(ally => ally.hp > 0 && (ally.hp / ally.maxHp) < 0.35);
        const isShieldMode = pl.id === 'H' && anyAllyLow;
        let hpFillClass = 'hp-fill';
        if(pl.id === 'K') hpFillClass += ' kevin';
        if(isFury) hpFillClass += ' fury';
        if(isShieldMode) hpFillClass += ' shield-mode';

        // Indicador de estado especial
        let stateIcon = '';
        if(isFury) stateIcon = ' üî•';
        if(isShieldMode) stateIcon = ' üõ°Ô∏è';

        row.innerHTML = `
            <span class="hp-name">${pl.name}${stateIcon}</span>
            <div class="hp-bar">
                <div class="${hpFillClass}" style="width:${pct}%"></div>
            </div>
            <span class="hp-cop">${fmt(pl.hp)}</span>
            <span style="font-size:9px; min-width:50px; text-align:center;">PA:${pl.pa} PM:${pl.pm}</span>
            <span style="font-size:8px; min-width:60px;">${buffs}</span>
        `;
        hpPanels.appendChild(row);
    });

    const ports = document.getElementById('portraits');
    ports.innerHTML = '';
    const spriteMap = {'J': 'aleman.png', 'H': 'h.png', 'K': 'joven.png'};

    // Detectar combo pendiente para efecto Ultra Instinto
    const comboInfo = getComboFinisher();

    players.forEach((pl, i) => {
        if(pl.hp <= 0) return;
        const div = document.createElement('div');
        const isFury = pl.id === 'J' && (pl.hp / pl.maxHp) < 0.50;
        const anyAllyLow = players.some(ally => ally.hp > 0 && (ally.hp / ally.maxHp) < 0.35);
        const isShieldMode = pl.id === 'H' && anyAllyLow;
        const isUltraInstinct = comboInfo && comboInfo.finisher === 'Pu√±o' && pl.id === 'J';
        div.className = `portrait ${i===activeIdx?'active':''} ${!enemyTurnActive && i===activeIdx?'turn':''} ${isFury?'fury':''} ${isShieldMode?'shield-mode':''} ${isUltraInstinct?'ultra-instinct':''}`;
        const img = document.createElement('img'); img.src = spriteMap[pl.id];
        div.appendChild(img);
        div.onclick = () => { if(!enemyTurnActive){ activeIdx=i; resetActions(); draw(); }};
        ports.appendChild(div);
    });

    const sBar = document.getElementById('spells-inner');
    sBar.innerHTML = '';
    p.spells.forEach(s => {
        const btn = document.createElement('button');
        // Efecto Ultra Instinto en el bot√≥n de Pu√±o cuando se puede completar combo
        const isComboFinisher = comboInfo && comboInfo.finisher === s;
        btn.className = `spellBtn ${selectedSpell===s?'selected':''} ${isComboFinisher?'ultra-instinct':''}`;
        btn.textContent = isComboFinisher ? `‚ö°${s}‚ö°` : s;
        btn.onclick = () => { if(!enemyTurnActive){ selectedSpell=(selectedSpell===s?null:s); isMoving=false; draw(); }};
        sBar.appendChild(btn);
    });

    const ePanel = document.getElementById('enemy-panels');
    ePanel.innerHTML = '';
    enemies.forEach(e => {
        const div = document.createElement('div');
        const isBoss = e.isBoss;
        div.className = `enemy-card${highlightedEnemy === e.id ? ' highlighted' : ''}${isBoss ? ' boss-card' : ''}`;
        // Mostrar buffs/debuffs
        let buffs = '';
        if(e.dmgBoost) buffs += `<span style="color:#4dff4d;">+${Math.round(e.dmgBoost*100)}%DMG</span> `;
        if(e.resistance) buffs += `<span style="color:#3498db;">${Math.round(e.resistance*100)}%RES</span> `;
        if(e.vulnerability) buffs += `<span style="color:#ff6b6b;">-${Math.round(e.vulnerability*100)}%DEF</span> `;

        // Barra de HP para boss
        const hpPercent = Math.max(0, (e.hp / e.maxHp) * 100);
        const hpBar = isBoss ? `
            <div style="width:100%;height:8px;background:#333;border-radius:4px;margin:4px 0;overflow:hidden;">
                <div style="width:${hpPercent}%;height:100%;background:linear-gradient(90deg,#8e44ad,#9b59b6);transition:width 0.3s;"></div>
            </div>
        ` : '';

        div.innerHTML = `
            <b style="${isBoss ? 'color:#9b59b6;font-size:12px;' : ''}">${e.name}</b><br>
            ${hpBar}
            <span style="color:${isBoss ? '#9b59b6' : '#f39c12'};">${fmt(e.hp)}</span><br>
            <span style="font-size:9px; color:#aaa;">PA:${e.pa} PM:${e.pm}</span><br>
            <span style="font-size:8px;">${buffs || '<span style="color:#666;">-</span>'}</span>
        `;
        // Clic en tarjeta tambi√©n resalta/deselecciona
        div.onclick = () => {
            highlightedEnemy = (highlightedEnemy === e.id) ? null : e.id;
            draw();
        };
        div.style.cursor = 'pointer';
        ePanel.appendChild(div);
    });

    // Mostrar fueguitos si hay
    if(fueguitos.length > 0) {
        const fuegoDiv = document.createElement('div');
        fuegoDiv.className = 'enemy-card';
        fuegoDiv.style.borderColor = '#e67e22';
        fuegoDiv.innerHTML = `
            <b style="color:#e67e22;">üî• Fueguitos</b><br>
            <span style="color:#f39c12;">${fueguitos.length} activos</span><br>
            <span style="font-size:9px; color:#ff6b6b;">¬°Explotan al inicio del turno enemigo!</span>
        `;
        ePanel.appendChild(fuegoDiv);
    }
}

function resetActions() { isMoving = false; selectedSpell = null; }

function onCellClick(x,y, cost) {
    if(enemyTurnActive) return;
    const p = players[activeIdx];

    // Verificar si hizo clic en un enemigo para resaltarlo
    const clickedEnemy = enemies.find(e => e.x === x && e.y === y && e.hp > 0);
    if(clickedEnemy && !selectedSpell) {
        // Toggle: si ya est√° resaltado, quitarlo; si no, resaltarlo
        highlightedEnemy = (highlightedEnemy === clickedEnemy.id) ? null : clickedEnemy.id;
        draw();
        // No retornar si hay hechizo para poder atacar
        if(!selectedSpell) return;
    }

    // Verificar si hizo clic en alg√∫n jugador para seleccionarlo
    const clickedPlayer = players.find(pl => pl.x === x && pl.y === y && pl.hp > 0);
    if(clickedPlayer && clickedPlayer !== p) {
        // Si no hay hechizo seleccionado, cambiar al personaje clickeado
        if(!selectedSpell) {
            const newIdx = players.indexOf(clickedPlayer);
            if(newIdx !== -1) {
                activeIdx = newIdx;
                highlightedEnemy = null; // Limpiar resaltado
                resetActions();
                draw();
                return;
            }
        }
    }

    // Si hay un hechizo seleccionado que se puede usar en la propia casilla (como Credito)
    if(selectedSpell && x === p.x && y === p.y && checkSpellRange(x,y)) {
        executeSpell(x,y);
        return;
    }

    // Clic en el personaje activo: activar modo movimiento
    if(x === p.x && y === p.y) { isMoving = !isMoving; selectedSpell = null; draw(); return; }
    if(isMoving && cost !== undefined) {
        p.x = x; p.y = y; p.pm -= cost;
        if(p.carried) { p.carried.x = x; p.carried.y = y; } // Mover al cargado
        isMoving = false; draw(); return;
    }
    if(selectedSpell && checkSpellRange(x,y)) executeSpell(x,y);
}

function checkSpellRange(x,y) {
    const p = players[activeIdx];
    const d = Math.abs(p.x-x) + Math.abs(p.y-y);

    // Validar PA antes de mostrar rango
    const spellCosts = {
        'Salto': 1, 'Insulto': 2, 'Empujon': 2, 'Cargar': 2, 'Lanzar': 2,
        'Pu√±o': 3, 'Credito': 3, 'Uva': 3, 'Atraco': 3
    };
    let cost = spellCosts[selectedSpell] || 3;
    if(p.pa < cost) return false;

    if(selectedSpell === 'Credito') return d === 0;
    if(['Pu√±o','Empujon','Cargar'].includes(selectedSpell)) return d === 1;
    // Uva: invocar (adyacente), intercambiar (sobre Uva), o comandar (sobre enemigo/aliado si Uva existe)
    if(selectedSpell === 'Uva') {
        if(uva && uva.x === x && uva.y === y) return true; // Intercambiar con Uva
        if(uva && getEntityAt(x, y) && getEntityAt(x, y) !== p) return true; // Comandar Uva a atacar/boostear
        return d === 1 && !uvaUsed; // Invocar (solo si no ha sido invocada)
    }
    if(selectedSpell === 'Insulto') return (p.x===x || p.y===y) && d >= 2 && d <= 3;
    // Salto: cardinales 2-5, diagonales 1-4
    if(selectedSpell === 'Salto') {
        const dx = Math.abs(p.x - x);
        const dy = Math.abs(p.y - y);
        const isCardinal = (dx === 0 || dy === 0);
        const isDiagonal = (dx === dy);
        if(!getEntityAt(x,y) && map[y][x] === 0) {
            if(isCardinal && d >= 2 && d <= 5) return true;
            if(isDiagonal && d >= 1 && d <= 4) return true;
        }
        return false;
    }
    // Atraco: SOLO diagonales (1 casilla)
    if(selectedSpell === 'Atraco') {
        const dx = Math.abs(p.x - x);
        const dy = Math.abs(p.y - y);
        return (dx === 1 && dy === 1); // Solo diagonal
    }
    if(selectedSpell === 'Lanzar') return p.carried && d <= 4 && !getEntityAt(x,y) && map[y][x]===0;
    return false;
}

function executeSpell(x,y) {
    const p = players[activeIdx];
    const target = getEntityAt(x,y);

    // Validar PA seg√∫n el costo del hechizo
    const spellCosts = {
        'Salto': 1,
        'Insulto': 2,
        'Empujon': 2,
        'Cargar': 2,
        'Lanzar': 2,
        'Pu√±o': 3,
        'Credito': 3,
        'Uva': 3,
        'Atraco': 3
    };
    let cost = spellCosts[selectedSpell] || 3;
    if(p.pa < cost) {
        log(`No tienes suficientes PA para usar ${selectedSpell} (necesitas ${cost})`, 'log-dmg');
        return;
    }

    // DA√ëOS: Pu√±o (600k-800k) > Empuj√≥n (450k-600k) > Insulto/Atraco (300k-450k)
    if(selectedSpell === 'Pu√±o') {
        if(target && target !== p) {
            applyDamage(target, 600000 + Math.random()*200000, selectedSpell, p);
            // Buff: El Alem√°n gana +5% da√±o acumulable por 2 turnos
            addEffect(p, 'dmgBoost', 0.05, 2);
            log(`${p.name} se enfurece: +5% da√±o por 2 turnos!`, 'log-heal');
        }
    }
    else if(selectedSpell === 'Insulto') {
        if(target && target !== p) {
            applyDamage(target, 300000 + Math.random()*150000, selectedSpell, p);
            // Debuff: objetivo recibe +5% da√±o por 1 turno
            addEffect(target, 'vulnerability', 0.05, 1);

            // Probabilidad de quitar 1 PA
            if(Math.random() < 0.5) {
                target.paPenalty = (target.paPenalty || 0) + 1;
                log(`${target.name} queda confundido: -1 PA pr√≥ximo turno!`, 'log-dmg');
            }

            // Atraer al objetivo 1 casilla hacia el Alem√°n
            const dx = Math.sign(p.x - target.x);
            const dy = Math.sign(p.y - target.y);
            const newX = target.x + dx;
            const newY = target.y + dy;
            if(newX >= 0 && newX < SIZE && newY >= 0 && newY < SIZE &&
               map[newY][newX] === 0 && !getEntityAt(newX, newY)) {
                target.x = newX;
                target.y = newY;
                log(`${p.name} atrae a ${target.name} 1 casilla!`, 'log-dmg');
            }

            log(`${target.name} est√° debilitado: +5% da√±o recibido por 1 turno!`, 'log-dmg');
            p.pa -= 2; selectedSpell = null; draw(); return; // Cuesta 2 PA
        }
    }
    else if(selectedSpell === 'Atraco') {
        if(target && target !== p) {
            // === ATRACO EN CADENA DIAGONAL ===
            // Busca enemigos en cadena diagonal: cada uno en diagonal del anterior
            // Da√±o se duplica con cada objetivo en la cadena

            const chain = [target]; // Cadena de objetivos
            let currentPos = { x: target.x, y: target.y };

            // Buscar m√°s enemigos en diagonales del objetivo actual
            const diagonals = [{dx:1,dy:1}, {dx:1,dy:-1}, {dx:-1,dy:1}, {dx:-1,dy:-1}];

            // Funci√≥n para buscar siguiente en cadena
            function findNextInChain(fromX, fromY, excludeIds) {
                for(const dir of diagonals) {
                    const nx = fromX + dir.dx;
                    const ny = fromY + dir.dy;
                    const ent = getEntityAt(nx, ny);
                    if(ent && ent.id && ent.id.includes('D') && ent.hp > 0 && !excludeIds.includes(ent.id)) {
                        return ent;
                    }
                }
                return null;
            }

            // Construir cadena (buscar hasta que no haya m√°s)
            let excludeIds = [target.id];
            let next = findNextInChain(currentPos.x, currentPos.y, excludeIds);
            while(next) {
                chain.push(next);
                excludeIds.push(next.id);
                currentPos = { x: next.x, y: next.y };
                next = findNextInChain(currentPos.x, currentPos.y, excludeIds);
            }

            // Aplicar da√±o en cadena con multiplicador x2 por cada objetivo
            const baseDmg = 300000 + Math.random() * 150000;
            let totalRecovered = 0;

            if(chain.length >= 3) {
                log(`üí• ¬°¬°ATRACO EN CADENA x${chain.length}!! üîó`, 'log-dmg');
                AudioManager.playSFX('critico');
            }

            chain.forEach((enemy, idx) => {
                const dmg = baseDmg; // Mismo da√±o para todos

                if(idx > 0) {
                    log(`üîó Cadena ${idx + 1}!`, 'log-heal');
                }

                applyDamage(enemy, dmg, idx === 0 ? selectedSpell : `Atraco (cadena)`, p);
                totalRecovered += dmg * 0.50;

                // Intercambiar posici√≥n con cada objetivo (uno por uno)
                const oldX = p.x, oldY = p.y;
                p.x = enemy.x; p.y = enemy.y;
                enemy.x = oldX; enemy.y = oldY;
            });

            // Kevin recupera 50% del da√±o total infligido
            const kevin = players.find(pl => pl.id === 'K');
            kevin.hp = Math.min(kevin.maxHp, kevin.hp + totalRecovered);
            log(`${kevin.name} recupera ${fmt(totalRecovered)} del atraco!`, 'log-heal');

            if(chain.length > 1) {
                log(`${p.name} atraves√≥ ${chain.length} enemigos!`, 'log-heal');
            } else {
                log(`${p.name} intercambi√≥ posici√≥n con ${target.name}!`, 'log-heal');
            }
        }
    }
    else if(selectedSpell === 'Empujon') {
        if(target && target !== p) {
            const isAlly = players.includes(target);
            const dx = target.x - p.x;
            const dy = target.y - p.y;
            let pushed = 0;
            let collision = false;

            // Verificar si ya est√° contra la pared
            const firstX = target.x + dx;
            const firstY = target.y + dy;
            const againstWall = (firstX < 0 || firstX >= SIZE || firstY < 0 || firstY >= SIZE ||
                                 map[firstY][firstX] === 1 || getEntityAt(firstX, firstY));

            if(isAlly) {
                // Empuj√≥n sobre aliado: empuja + buff de da√±o
                if(!againstWall) {
                    // Intentar empujar 2 casillas
                    for(let i = 1; i <= 2; i++) {
                        const nx = target.x + dx * i;
                        const ny = target.y + dy * i;
                        if(nx < 0 || nx >= SIZE || ny < 0 || ny >= SIZE) break;
                        if(map[ny][nx] === 1) break;
                        if(getEntityAt(nx, ny)) break;
                        pushed = i;
                    }
                    if(pushed > 0) {
                        target.x = target.x + dx * pushed;
                        target.y = target.y + dy * pushed;
                        log(`${target.name} fue impulsado ${pushed} casilla(s)!`, 'log-heal');
                    }
                }
                // Buff de da√±o +10% este turno
                target.dmgBoost = (target.dmgBoost || 0) + 0.10;
                log(`${p.name} motiva a ${target.name}: +10% da√±o este turno!`, 'log-heal');
            } else {
                // Empuj√≥n sobre enemigo: da√±o por colisi√≥n
                if(againstWall) {
                    const wallDmg = 600000 + Math.random()*200000;
                    applyDamage(target, wallDmg, "Empujon (APLASTADO)", p, true); // Ignora resistencia
                    log(`${target.name} fue APLASTADO contra la pared!`, 'log-dmg');
                } else {
                    for(let i = 1; i <= 2; i++) {
                        const nx = target.x + dx * i;
                        const ny = target.y + dy * i;
                        if(nx < 0 || nx >= SIZE || ny < 0 || ny >= SIZE) { collision = true; break; }
                        if(map[ny][nx] === 1) { collision = true; break; }
                        if(getEntityAt(nx, ny)) { collision = true; break; }
                        pushed = i;
                    }

                    if(pushed > 0) {
                        target.x = target.x + dx * pushed;
                        target.y = target.y + dy * pushed;

                        if(collision) {
                            const collisionDmg = 350000 + Math.random()*150000;
                            applyDamage(target, collisionDmg, "Empujon (colisi√≥n)", p, true); // Ignora resistencia
                            log(`${target.name} fue empujado ${pushed} casilla(s) y CHOC√ì!`, 'log-dmg');
                        } else {
                            log(`${target.name} fue empujado ${pushed} casilla(s).`);
                            // Trackear empuj√≥n sin da√±o para el combo
                            if(!comboTracker[target.id]) comboTracker[target.id] = [];
                            comboTracker[target.id].push({ spell: 'Empujon', dmg: 0 });
                            notifyComboProgress(target.id);
                        }
                    } else {
                        // Empuj√≥n sin movimiento pero a√∫n cuenta para combo
                        if(!comboTracker[target.id]) comboTracker[target.id] = [];
                        comboTracker[target.id].push({ spell: 'Empujon', dmg: 0 });
                        notifyComboProgress(target.id);
                    }
                }
            }
            // Pasiva de H: gana 7-12% resistencia por empujar (dura 2 turnos)
            const resBonus = 0.07 + Math.random() * 0.05; // 7-12%
            addEffect(p, 'resistance', resBonus, 2);
            log(`üõ°Ô∏è Fortaleza de H: +${Math.round(resBonus*100)}% resistencia por 2 turnos!`, 'log-heal');
            p.pa -= cost; selectedSpell = null; draw(); return;
        }
    }
    else if(selectedSpell === 'Credito') {
        AudioManager.playSFX('credito');
        let heal = 550000;
        const isCrit = rollCrit();
        if(isCrit) {
            heal *= CRIT_MULTIPLIER;
            AudioManager.playSFX('critico');
            log(`üíö ¬°CURACI√ìN CR√çTICA! +50% curaci√≥n`, 'log-heal');
        }
        // Kevin siempre recibe la curaci√≥n
        const kevin = players.find(pl => pl.id === 'K');
        kevin.hp = Math.min(kevin.maxHp, kevin.hp + heal);
        log(`${kevin.name} recibe consignaci√≥n: +${fmt(heal)}${isCrit ? ' üíö' : ''}`, 'log-heal');
        // Aliados adyacentes a Kevin tambi√©n reciben
        players.forEach(pl => {
            if(pl.id !== 'K' && pl.hp > 0 && Math.abs(kevin.x-pl.x)+Math.abs(kevin.y-pl.y) <= 1) {
                pl.hp = Math.min(pl.maxHp, pl.hp + heal);
                log(`${pl.name} recibe consignaci√≥n: +${fmt(heal)}${isCrit ? ' üíö' : ''}`, 'log-heal');
            }
        });
    } 
    else if(selectedSpell === 'Uva') {
        AudioManager.playSFX('uva');
        // Si Uva est√° en la celda objetivo, intercambiar posici√≥n
        if(uva && uva.x === x && uva.y === y) {
            const oldX = p.x, oldY = p.y;
            p.x = uva.x; p.y = uva.y;
            uva.x = oldX; uva.y = oldY;
            log(`${p.name} intercambi√≥ posici√≥n con Uva üê∂!`, 'log-heal');
        }
        // Si Uva existe y hay un objetivo en la celda, comandar a Uva
        else if(uva && target && target !== p && target.id !== 'U') {
            commandUva(target);
        }
        // Invocar Uva por primera vez
        else {
            if(uvaUsed) {
                log("¬°Uva üê∂ ya fue invocada este combate! No puede volver.", 'log-dmg');
                selectedSpell = null; draw(); return;
            }
            uva = {id:'U', name:'Uva üê∂', x, y, hp:800000, maxHp:800000};
            uvaUsed = true;
            log("¬°Uva üê∂ ENTE DEL CAOS ha entrado al mapa! ¬øQu√© har√°?");
            // 1/2 de probabilidad: todos ganan PA por 2 turnos (+6 si GC, +3 normal)
            if(Math.random() < 0.5) {
                const isCrit = rollCrit();
                const paAmount = isCrit ? 6 : 3;
                players.filter(pl => pl.hp > 0).forEach(pl => {
                    addEffect(pl, 'paBonus', paAmount, 2);
                });
                if(isCrit) {
                    AudioManager.playSFX('critico');
                    log("üê∂üí• ¬°¬°GOLPE CR√çTICO!! ¬°Uva desata su poder! +6 PA a todos por 2 turnos!", 'log-heal');
                } else {
                    log("üê∂üí´ ¬°La energ√≠a ca√≥tica de Uva inspira al equipo! +3 PA a todos por 2 turnos!", 'log-heal');
                }
            }
        }
    }
    else if(selectedSpell === 'Salto') {
        AudioManager.playSFX('salto');
        p.x = x; p.y = y;
        p.pa -= 1; selectedSpell = null; draw(); return; // Cuesta 1 PA
    }
    else if(selectedSpell === 'Cargar') {
        if(target && target !== p) {
            AudioManager.playSFX('cargar');
            p.carried = target;
            log(`${p.name} carg√≥ a ${target.name}`);
            p.pa -= cost; selectedSpell = null; draw(); return;
        }
    }
    else if(selectedSpell === 'Lanzar') {
        if(p.carried) {
            AudioManager.playSFX('lanzar');
            p.carried.x = x; p.carried.y = y;
            log(`${p.name} lanz√≥ a ${p.carried.name}`);
            p.carried = null;
            // Pasiva de H: gana 7-12% resistencia por lanzar (dura 2 turnos)
            const resBonus = 0.07 + Math.random() * 0.05; // 7-12%
            addEffect(p, 'resistance', resBonus, 2);
            log(`üõ°Ô∏è Fortaleza de H: +${Math.round(resBonus*100)}% resistencia por 2 turnos!`, 'log-heal');
            p.pa -= cost; selectedSpell = null; draw(); return;
        }
    }

    p.pa -= 3; selectedSpell = null; draw();
}

// ===== TURNO ESCOTES + UVA =====
document.getElementById('endTurnBtn').onclick = () => { if(!enemyTurnActive) startEnemyTurn(); };

// Contador global de turnos para el boss
let turnCounter = 0;
let jovenAloneMessageShown = false; // Para no repetir el mensaje de doom

// Sistema de combos de La Diabla
let diablaComboTracker = {}; // {targetId: [ataque1, ataque2, ...]}

// Registrar ataque de Diabla para combo
function trackDiablaAttack(targetId, attackName) {
    if(!diablaComboTracker[targetId]) diablaComboTracker[targetId] = [];
    diablaComboTracker[targetId].push(attackName);

    // M√°ximo 5 ataques en memoria
    if(diablaComboTracker[targetId].length > 5) {
        diablaComboTracker[targetId].shift();
    }
}

// Verificar y ejecutar combo de Diabla
function checkDiablaCombo(targetId, diabla) {
    const hits = diablaComboTracker[targetId];
    if(!hits || hits.length < 3) return false;

    const last3 = hits.slice(-3);
    const target = players.find(p => p.id === targetId);
    if(!target || target.hp <= 0) return false;

    // COMBO 1: Placaje + Pu√±o + Pu√±o = "Demolici√≥n" (600K da√±o puro)
    if(last3[0] === 'Placaje' && last3[1] === 'Pu√±o' && last3[2] === 'Pu√±o') {
        log(``, '');
        log(`üëøüî•üíÄ ¬°¬°COMBO DIAB√ìLICO: DEMOLICI√ìN!! üíÄüî•üëø`, 'log-dmg');
        log(`Placaje ‚Üí Pu√±o ‚Üí Pu√±o = ¬°DEVASTACI√ìN!`, 'log-dmg');
        AudioManager.playSFX('critico');

        const comboDmg = 600000; // 600K da√±o puro
        target.hp -= comboDmg; // Ignora resistencias
        log(`${target.name} recibe ${fmt(comboDmg)} de DA√ëO PURO (ignora resistencias)!`, 'log-dmg');

        diablaComboTracker[targetId] = []; // Reset combo
        return true;
    }

    // COMBO 2: Empuj√≥n + Empuj√≥n + Pu√±o = "Acorralamiento" (450K da√±o puro + quita 2 PA)
    if(last3[0] === 'Empuj√≥n' && last3[1] === 'Empuj√≥n' && last3[2] === 'Pu√±o') {
        log(``, '');
        log(`üëøüí¢‚ö° ¬°¬°COMBO DIAB√ìLICO: ACORRALAMIENTO!! ‚ö°üí¢üëø`, 'log-dmg');
        log(`Empuj√≥n ‚Üí Empuj√≥n ‚Üí Pu√±o = ¬°SIN ESCAPE!`, 'log-dmg');
        AudioManager.playSFX('critico');

        const comboDmg = 450000; // 450K da√±o puro
        target.hp -= comboDmg;
        target.pa = Math.max(0, (target.pa || 6) - 2); // Quita 2 PA
        log(`${target.name} recibe ${fmt(comboDmg)} de DA√ëO PURO y pierde 2 PA!`, 'log-dmg');

        diablaComboTracker[targetId] = [];
        return true;
    }

    // COMBO 3: Lanzamiento + Pu√±o + Pu√±o = "Castigo Infernal" (500K da√±o puro + reduce resistencia)
    if(last3[0] === 'Lanzamiento' && last3[1] === 'Pu√±o' && last3[2] === 'Pu√±o') {
        log(``, '');
        log(`üëøüî•üòà ¬°¬°COMBO DIAB√ìLICO: CASTIGO INFERNAL!! üòàüî•üëø`, 'log-dmg');
        log(`Lanzamiento ‚Üí Pu√±o ‚Üí Pu√±o = ¬°DESTRUCCI√ìN!`, 'log-dmg');
        AudioManager.playSFX('critico');

        const comboDmg = 500000; // 500K da√±o puro
        target.hp -= comboDmg;
        // Reducir resistencia permanentemente (si tiene)
        if(target.resistance) {
            target.resistance = Math.max(0, target.resistance - 0.10);
            log(`${target.name} pierde 10% de resistencia permanentemente!`, 'log-dmg');
        }
        log(`${target.name} recibe ${fmt(comboDmg)} de DA√ëO PURO!`, 'log-dmg');

        diablaComboTracker[targetId] = [];
        return true;
    }

    // COMBO 4: Ira + Pu√±o + Pu√±o = "Furia Demon√≠aca" (750K da√±o puro - el m√°s fuerte)
    if(last3[0] === 'Ira' && last3[1] === 'Pu√±o' && last3[2] === 'Pu√±o') {
        log(``, '');
        log(`üëøüíÄüî• ¬°¬°COMBO DIAB√ìLICO: FURIA DEMON√çACA!! üî•üíÄüëø`, 'log-dmg');
        log(`Ira ‚Üí Pu√±o ‚Üí Pu√±o = ¬°ANIQUILACI√ìN TOTAL!`, 'log-dmg');
        AudioManager.playSFX('critico');

        const comboDmg = 750000; // 750K da√±o puro
        target.hp -= comboDmg;
        log(`${target.name} recibe ${fmt(comboDmg)} de DA√ëO PURO (ignora resistencias)!`, 'log-dmg');

        diablaComboTracker[targetId] = [];
        return true;
    }

    return false;
}

// ===== IA DE LA DIABLA (BOSS FINAL) =====
function actDiabla(diabla) {
    const alivePlayers = players.filter(pl => pl.hp > 0);
    if(alivePlayers.length === 0) return;

    const config = levelConfig[currentLevel];
    const joven = alivePlayers.find(pl => pl.id === 'K');
    const aleman = alivePlayers.find(pl => pl.id === 'A');
    const h = alivePlayers.find(pl => pl.id === 'H');

    // ESTRATEGIA: Priorizar eliminar al Alem√°n primero (contrarrestar su da√±o acumulado)
    // Luego H, y finalmente el Joven (dejarlo indefenso)
    let target;
    if(aleman) {
        target = aleman; // Prioridad 1: Alem√°n (sus golpes acumulados son peligrosos)
    } else if(h) {
        target = h; // Prioridad 2: H (el protector)
    } else {
        target = joven; // Prioridad 3: El Joven (el objetivo final)
    }

    // Verificar si el Joven qued√≥ solo (H y Alem√°n muertos) - solo mostrar una vez
    if(joven && !aleman && !h && !jovenAloneMessageShown) {
        const aliveAllies = alivePlayers.filter(pl => pl.id !== 'K');
        if(aliveAllies.length === 0) {
            log(``, '');
            log(`üòàüíÄ "La Diabla qued√≥ a solas con el joven..." üíÄüòà`, 'log-dmg');
            log(`üò± "Ya vali√≥..." üò±`, 'log-dmg');
            log(``, '');
            jovenAloneMessageShown = true;
        }
    }

    // Estado de furia: < 30% HP
    const isFury = diabla.hp / diabla.maxHp < 0.30;
    if(isFury) {
        log(`üî•üëø ¬°LA DIABLA EST√Å FURIOSA! üî•`, 'log-dmg');
    }

    let paUsed = 0;
    const maxPA = diabla.pa; // 9 PA

    // === FASE 1: MOVIMIENTO T√ÅCTICO (arrinconar al Joven) ===
    // Funci√≥n para evaluar qu√© tan "arrinconado" est√° un jugador en una posici√≥n
    function getCornerScore(px, py) {
        let score = 0;
        // M√°s cerca de las esquinas/bordes = mejor
        score += Math.min(px, SIZE - 1 - px) <= 1 ? 2 : 0;
        score += Math.min(py, SIZE - 1 - py) <= 1 ? 2 : 0;
        // Contar muros/bordes adyacentes
        const dirs = [{dx:0,dy:-1},{dx:0,dy:1},{dx:-1,dy:0},{dx:1,dy:0}];
        dirs.forEach(d => {
            const nx = px + d.dx, ny = py + d.dy;
            if(nx < 0 || nx >= SIZE || ny < 0 || ny >= SIZE || map[ny][nx] === 1) {
                score += 1;
            }
        });
        return score;
    }

    for(let i = 0; i < diabla.pm; i++) {
        const currentDist = Math.abs(diabla.x - target.x) + Math.abs(diabla.y - target.y);
        if(currentDist <= 1) break;

        let reach = calculateReach(diabla.x, diabla.y, 1);
        let best = null;
        let bestScore = -999;

        for(let key of reach.keys()) {
            let [nx, ny] = key.split(',').map(Number);
            let dist = Math.abs(nx - target.x) + Math.abs(ny - target.y);

            // Calcular score: priorizar posiciones que empujen al Joven hacia esquinas
            // Direcci√≥n en que empujar√≠amos al Joven desde esta posici√≥n
            const pushDirX = target.x - nx;
            const pushDirY = target.y - ny;
            const potentialPushX = target.x + Math.sign(pushDirX);
            const potentialPushY = target.y + Math.sign(pushDirY);

            let score = 0;
            score -= dist * 2; // Acercarse sigue siendo importante

            // Bonus si desde esta posici√≥n empujar√≠amos al Joven hacia una esquina/muro
            if(dist === 1) {
                const cornerScore = getCornerScore(potentialPushX, potentialPushY);
                score += cornerScore * 3;

                // Bonus extra si el empuj√≥n causar√≠a colisi√≥n
                if(potentialPushX < 0 || potentialPushX >= SIZE ||
                   potentialPushY < 0 || potentialPushY >= SIZE ||
                   map[potentialPushY]?.[potentialPushX] === 1 ||
                   getEntityAt(potentialPushX, potentialPushY)) {
                    score += 10; // ¬°Colisi√≥n asegurada!
                    log(`üëø La Diabla ve una oportunidad de colisi√≥n...`, 'log-dmg');
                }
            }

            if(score > bestScore) {
                best = {x: nx, y: ny};
                bestScore = score;
            }
        }

        if(best) {
            diabla.x = best.x;
            diabla.y = best.y;
        }
    }

    // === FASE 2: ¬°SU√âLTAME! (cada 3 turnos, empuja 3 casillas a TODOS los adyacentes, cuesta 3 PA) ===
    const allAdjacent = alivePlayers.filter(pl =>
        Math.abs(diabla.x - pl.x) + Math.abs(diabla.y - pl.y) === 1
    );
    if(allAdjacent.length >= 2 && turnCounter - diabla.lastSueltameUsed >= 3 && paUsed + 3 <= maxPA) {
        log(`üëøüí¢ ¬°¬°SU√âLTAME!! üí¢üëø`, 'log-dmg');
        AudioManager.playSFX('critico');

        allAdjacent.forEach(pl => {
            const dx = Math.sign(pl.x - diabla.x);
            const dy = Math.sign(pl.y - diabla.y);

            // Empujar hasta 3 casillas
            let finalX = pl.x;
            let finalY = pl.y;
            let pushed = 0;

            for(let i = 1; i <= 3; i++) {
                const nx = pl.x + dx * i;
                const ny = pl.y + dy * i;

                // Verificar l√≠mites del tablero
                if(nx < 0 || nx >= SIZE || ny < 0 || ny >= SIZE ||
                   map[ny][nx] === 1 || getEntityAt(nx, ny)) {
                    // Colisi√≥n
                    const collisionDmg = 250000 + Math.random() * 150000;
                    applyDamage(pl, collisionDmg, "¬°Su√©ltame! (colisi√≥n)", diabla);
                    break;
                }
                finalX = nx;
                finalY = ny;
                pushed++;
            }

            if(pushed > 0) {
                pl.x = finalX;
                pl.y = finalY;
                log(`${pl.name} es lanzado ${pushed} casillas!`, 'log-dmg');
            }
        });

        diabla.lastSueltameUsed = turnCounter;
        paUsed += 3;
    }

    // === FASE 3: GRITO (cada 4 turnos, quita TODOS los buffs del objetivo, cuesta 2 PA) ===
    const buffedPlayers = alivePlayers.filter(pl =>
        pl.dmgBoost || pl.resistance
    );
    if(buffedPlayers.length > 0 && turnCounter - diabla.lastGritoUsed >= 4 && paUsed + 2 <= maxPA) {
        // Priorizar a Kevin si tiene buffs
        const gritoTarget = buffedPlayers.find(pl => pl.id === 'K') || buffedPlayers[0];

        log(`üëøüò± ¬°¬°GRITO INFERNAL!! üò±üëø`, 'log-dmg');
        AudioManager.playSFX('critico');

        // Quitar todos los buffs
        const hadDmgBoost = gritoTarget.dmgBoost;
        const hadResistance = gritoTarget.resistance;
        delete gritoTarget.dmgBoost;
        delete gritoTarget.resistance;

        let removedBuffs = [];
        if(hadDmgBoost) removedBuffs.push(`+${Math.round(hadDmgBoost*100)}% da√±o`);
        if(hadResistance) removedBuffs.push(`+${Math.round(hadResistance*100)}% resistencia`);

        log(`${gritoTarget.name} pierde: ${removedBuffs.join(', ')}!`, 'log-dmg');

        diabla.lastGritoUsed = turnCounter;
        paUsed += 2;
    }

    // === FASE 4: ATAQUE DE IRA (cada 2 turnos, cuesta 4 PA) ===
    if(turnCounter - diabla.lastIraUsed >= 2 && paUsed + 4 <= maxPA) {
        diablaIraAttack(diabla);
        diabla.lastIraUsed = turnCounter;
        paUsed += 4;
    }

    // === FASE 5: INVOCAR FUEGUITO (cuesta 3 PA, m√°ximo 3 fueguitos) ===
    if(fueguitos.length < 3 && paUsed + 3 <= maxPA) {
        diablaSpawnFueguito(diabla);
        paUsed += 3;
    }

    // === FASE 6: CARGAR Y LANZAR (estrat√©gico - buscar posiciones trampa) ===
    // Funci√≥n para evaluar qu√© tan "atrapada" estar√≠a una entidad en una posici√≥n
    function getTrapScore(px, py) {
        let blockedDirs = 0;
        const dirs = [{dx:0,dy:-1},{dx:0,dy:1},{dx:-1,dy:0},{dx:1,dy:0}];
        dirs.forEach(d => {
            const nx = px + d.dx, ny = py + d.dy;
            // Contar direcciones bloqueadas (borde, muro, o entidad)
            if(nx < 0 || nx >= SIZE || ny < 0 || ny >= SIZE ||
               map[ny][nx] === 1 || getEntityAt(nx, ny)) {
                blockedDirs++;
            }
        });
        // 4 = completamente atrapado, 3 = muy atrapado, 2 = parcialmente, etc.
        return blockedDirs;
    }

    // Priorizar cargar a H para dejarlo en posici√≥n trampa
    const adjacentAllies = alivePlayers.filter(pl =>
        pl.id !== 'K' &&
        Math.abs(diabla.x - pl.x) + Math.abs(diabla.y - pl.y) === 1
    );

    // Priorizar a H si est√° adyacente (para neutralizarlo en trampa)
    const carryTarget = adjacentAllies.find(pl => pl.id === 'H') || adjacentAllies[0];

    if(carryTarget && paUsed + 4 <= maxPA) { // 2 PA cargar + 2 PA lanzar
        // Cargar al personaje
        log(`üëø La Diabla CARGA a ${carryTarget.name}!`, 'log-dmg');
        diabla.carried = carryTarget;
        carryTarget.x = diabla.x;
        carryTarget.y = diabla.y;
        paUsed += 2;

        // Lanzar estrat√©gicamente - buscar la MEJOR posici√≥n trampa
        if(paUsed + 2 <= maxPA) {
            const throwDirs = [{dx:0,dy:-1},{dx:0,dy:1},{dx:-1,dy:0},{dx:1,dy:0},
                              {dx:1,dy:1},{dx:1,dy:-1},{dx:-1,dy:1},{dx:-1,dy:-1}]; // Incluir diagonales
            let bestThrow = null;
            let bestThrowScore = -999;

            // Buscar en TODO el rango posible de lanzamiento (hasta 4 casillas)
            for(const dir of throwDirs) {
                for(let dist = 4; dist >= 1; dist--) {
                    const landX = diabla.x + dir.dx * dist;
                    const landY = diabla.y + dir.dy * dist;

                    if(landX >= 0 && landX < SIZE && landY >= 0 && landY < SIZE &&
                       map[landY][landX] === 0 && !getEntityAt(landX, landY)) {

                        // Evaluar qu√© tan buena es esta posici√≥n
                        const trapScore = getTrapScore(landX, landY); // 0-4, m√°s alto = m√°s atrapado
                        const distToJoven = joven ? Math.abs(landX - joven.x) + Math.abs(landY - joven.y) : 0;
                        const cornerBonus = (Math.min(landX, SIZE-1-landX) <= 1 ? 2 : 0) +
                                           (Math.min(landY, SIZE-1-landY) <= 1 ? 2 : 0);

                        // Score: PRIORIZAR posiciones trampa para H
                        let score = trapScore * 10; // Mucho peso a posiciones atrapadas
                        score += cornerBonus * 3;   // Esquinas tambi√©n son buenas
                        score += distToJoven;       // Alejarlo del Joven
                        score += dist;              // M√°s lejos = m√°s da√±o de ca√≠da

                        // BONUS ENORME si es H y la posici√≥n tiene 3+ direcciones bloqueadas
                        if(carryTarget.id === 'H' && trapScore >= 3) {
                            score += 50; // Prioridad m√°xima: dejar a H sin opciones
                            log(`üëø La Diabla ve una trampa perfecta para ${carryTarget.name}...`, 'log-dmg');
                        }

                        if(score > bestThrowScore) {
                            bestThrow = {x: landX, y: landY, dist: dist, trapScore: trapScore};
                            bestThrowScore = score;
                        }
                    }
                }
            }

            if(bestThrow) {
                carryTarget.x = bestThrow.x;
                carryTarget.y = bestThrow.y;

                // Mensaje especial si lo dej√≥ atrapado
                if(bestThrow.trapScore >= 3) {
                    log(`üëøüòà La Diabla LANZA a ${carryTarget.name} a una TRAMPA! (${bestThrow.trapScore}/4 bloqueado)`, 'log-dmg');
                } else {
                    log(`üëø La Diabla LANZA a ${carryTarget.name} ${bestThrow.dist} casillas!`, 'log-dmg');
                }

                // Da√±o por ca√≠da (m√°s distancia = m√°s da√±o)
                const fallDmg = 200000 * bestThrow.dist;
                applyDamage(carryTarget, fallDmg, "Lanzamiento infernal", diabla);

                // Trackear para combo
                trackDiablaAttack(carryTarget.id, 'Lanzamiento');
                checkDiablaCombo(carryTarget.id, diabla);
            }
            diabla.carried = null;
            paUsed += 2;
        }
    }

    // === FASE 7: PLACAJE AL JOVEN (cuerpo a cuerpo, quita PM, cuesta 2 PA) ===
    const jovenAdjacent = alivePlayers.find(pl =>
        pl.id === 'K' && Math.abs(diabla.x - pl.x) + Math.abs(diabla.y - pl.y) === 1
    );

    if(jovenAdjacent && paUsed + 2 <= maxPA) {
        const placajeDmg = 400000 + Math.random() * 200000;
        applyDamage(jovenAdjacent, placajeDmg, "Placaje infernal", diabla);
        jovenAdjacent.pmPenalty = (jovenAdjacent.pmPenalty || 0) + 2;
        log(`üëø ¬°PLACAJE! ${jovenAdjacent.name} pierde 2 PM!`, 'log-dmg');

        // Trackear para combo
        trackDiablaAttack(jovenAdjacent.id, 'Placaje');
        checkDiablaCombo(jovenAdjacent.id, diabla);

        paUsed += 2;
    }

    // === FASE 8: EMPUJAR (a cualquiera adyacente, cuesta 2 PA) ===
    const adjacentPlayers = alivePlayers.filter(pl =>
        Math.abs(diabla.x - pl.x) + Math.abs(diabla.y - pl.y) === 1
    );

    while(adjacentPlayers.length > 0 && paUsed + 2 <= maxPA) {
        // Priorizar empujar al Joven hacia muros
        const pushTarget = adjacentPlayers.find(pl => pl.id === 'K') || adjacentPlayers[0];
        const dx = pushTarget.x - diabla.x;
        const dy = pushTarget.y - diabla.y;

        // Empujar 2 casillas
        let pushed = 0;
        let collision = false;
        for(let i = 1; i <= 2; i++) {
            const nx = pushTarget.x + dx * i;
            const ny = pushTarget.y + dy * i;
            if(nx >= 0 && nx < SIZE && ny >= 0 && ny < SIZE &&
               map[ny][nx] === 0 && !getEntityAt(nx, ny)) {
                pushed = i;
            } else {
                // Colisi√≥n
                collision = true;
                const collisionDmg = 300000 + Math.random() * 200000;
                applyDamage(pushTarget, collisionDmg, "Empuj√≥n infernal (colisi√≥n)", diabla);
                break;
            }
        }
        if(pushed > 0) {
            pushTarget.x += dx * pushed;
            pushTarget.y += dy * pushed;
            log(`üëø La Diabla empuja a ${pushTarget.name} ${pushed} casillas!`, 'log-dmg');
        }

        // Trackear para combo (empuj√≥n cuenta aunque no haya movido)
        trackDiablaAttack(pushTarget.id, 'Empuj√≥n');
        checkDiablaCombo(pushTarget.id, diabla);

        paUsed += 2;

        // Actualizar lista de adyacentes
        const stillAdjacent = alivePlayers.filter(pl =>
            Math.abs(diabla.x - pl.x) + Math.abs(diabla.y - pl.y) === 1
        );
        if(stillAdjacent.length === adjacentPlayers.length) break; // Evitar loop infinito
        adjacentPlayers.length = 0;
        adjacentPlayers.push(...stillAdjacent);
    }

    // === FASE 9: PU√ëO DEMON√çACO (cuerpo a cuerpo, cuesta 3 PA) ===
    // Puede atacar m√∫ltiples veces si tiene PA
    // Prioridad: Alem√°n > H > Joven (acabar con el que m√°s da√±o hace primero)
    while(paUsed + 3 <= maxPA) {
        const meleeTargets = alivePlayers.filter(pl =>
            Math.abs(diabla.x - pl.x) + Math.abs(diabla.y - pl.y) === 1
        );

        if(meleeTargets.length === 0) break;

        // Priorizar: Alem√°n primero, luego H, luego el Joven
        const punchTarget = meleeTargets.find(pl => pl.id === 'A') ||
                           meleeTargets.find(pl => pl.id === 'H') ||
                           meleeTargets.find(pl => pl.id === 'K') ||
                           meleeTargets[0];
        let baseDmg = config.baseDmgMin + Math.random() * (config.baseDmgMax - config.baseDmgMin);

        // Furia: da√±o x2
        if(isFury) {
            baseDmg *= 2;
            log(`üî• ¬°PU√ëO FURIOSO! Da√±o x2!`, 'log-dmg');
        }

        applyDamage(punchTarget, baseDmg, "Pu√±o Demon√≠aco", diabla);

        // Trackear para combo
        trackDiablaAttack(punchTarget.id, 'Pu√±o');
        checkDiablaCombo(punchTarget.id, diabla);

        paUsed += 3;
    }

    turnCounter++;
}

// Ataque de Ira: da√±a todas las cardinales y diagonales (no atraviesa obst√°culos)
function diablaIraAttack(diabla) {
    log(`üëøüî• ¬°¬°ATAQUE DE IRA!! üî•üëø`, 'log-dmg');
    AudioManager.playSFX('critico');

    const directions = [
        {dx: 0, dy: -1}, {dx: 0, dy: 1}, {dx: -1, dy: 0}, {dx: 1, dy: 0}, // Cardinales
        {dx: 1, dy: 1}, {dx: 1, dy: -1}, {dx: -1, dy: 1}, {dx: -1, dy: -1} // Diagonales
    ];

    const affectedCells = [];
    const config = levelConfig[currentLevel];
    const iraDmg = config.baseDmgMin * 0.7 + Math.random() * config.baseDmgMin * 0.3;

    // Para cada direcci√≥n, avanzar hasta encontrar obst√°culo
    directions.forEach(dir => {
        for(let i = 1; i < SIZE; i++) {
            const nx = diabla.x + dir.dx * i;
            const ny = diabla.y + dir.dy * i;

            // Fuera del mapa o muro = parar
            if(nx < 0 || nx >= SIZE || ny < 0 || ny >= SIZE || map[ny][nx] === 1) {
                break;
            }

            affectedCells.push({x: nx, y: ny});

            // Verificar si hay jugador en esta casilla
            const target = players.find(pl => pl.x === nx && pl.y === ny && pl.hp > 0);
            if(target) {
                applyDamage(target, iraDmg, "Ira de la Diabla", diabla);
                // Trackear para combo
                trackDiablaAttack(target.id, 'Ira');
            }
        }
    });

    // Verificar combos de todos los jugadores afectados por Ira
    players.filter(pl => pl.hp > 0).forEach(pl => {
        checkDiablaCombo(pl.id, diabla);
    });

    // Efecto visual: marcar casillas con fuego (parpadeo notable)
    affectedCells.forEach((cell, idx) => {
        // Delay escalonado para efecto de propagaci√≥n
        setTimeout(() => {
            const cellEl = document.querySelector(`#grid .cell:nth-child(${cell.y * SIZE + cell.x + 1})`);
            if(cellEl) {
                cellEl.classList.add('on-fire');
            }
        }, idx * 30); // Efecto de onda expansiva
    });

    // Quitar el fuego despu√©s de que el jugador lo vea bien (1.5 segundos)
    setTimeout(() => {
        affectedCells.forEach(cell => {
            const cellEl = document.querySelector(`#grid .cell:nth-child(${cell.y * SIZE + cell.x + 1})`);
            if(cellEl) {
                cellEl.classList.remove('on-fire');
            }
        });
    }, 1500);
}

// Invocar un fueguito
function diablaSpawnFueguito(diabla) {
    // Buscar casilla vac√≠a adyacente a la Diabla
    const adjacent = [
        {dx: 0, dy: -1}, {dx: 0, dy: 1}, {dx: -1, dy: 0}, {dx: 1, dy: 0},
        {dx: 1, dy: 1}, {dx: 1, dy: -1}, {dx: -1, dy: 1}, {dx: -1, dy: -1}
    ];

    for(const dir of adjacent) {
        const nx = diabla.x + dir.dx;
        const ny = diabla.y + dir.dy;

        if(nx >= 0 && nx < SIZE && ny >= 0 && ny < SIZE &&
           map[ny][nx] === 0 && !getEntityAt(nx, ny)) {
            const fueguitoId = 'FUEGO' + Date.now();
            fueguitos.push({
                id: fueguitoId,
                name: 'üî• Fueguito',
                x: nx,
                y: ny,
                turnsToExplode: 1 // Explota en el pr√≥ximo turno enemigo
            });
            log(`üëø La Diabla invoca un Fueguito en (${nx},${ny})!`, 'log-dmg');
            break;
        }
    }
}

// Procesar explosi√≥n de fueguitos
function processFueguitos() {
    if(fueguitos.length === 0) return;

    const toExplode = [...fueguitos];
    fueguitos = []; // Limpiar todos (explotan todos)

    toExplode.forEach(fuego => {
        log(`üî•üí• ¬°Fueguito EXPLOTA en (${fuego.x},${fuego.y})!`, 'log-dmg');

        // Afecta a todos los adyacentes (cardinales)
        const adjacent = [
            {dx: 0, dy: 0}, // La propia casilla
            {dx: 0, dy: -1}, {dx: 0, dy: 1}, {dx: -1, dy: 0}, {dx: 1, dy: 0}
        ];

        adjacent.forEach(dir => {
            const tx = fuego.x + dir.dx;
            const ty = fuego.y + dir.dy;

            const target = players.find(pl => pl.x === tx && pl.y === ty && pl.hp > 0);
            if(target) {
                // Da√±o por explosi√≥n
                const explosionDmg = 200000 + Math.random() * 150000;
                applyDamage(target, explosionDmg, "Explosi√≥n de Fueguito", {name: 'üî• Fueguito', id: 'FUEGO'});

                // Quitar 1 PA
                target.paPenalty = (target.paPenalty || 0) + 1;
                log(`${target.name} pierde 1 PA por la explosi√≥n!`, 'log-dmg');

                // Empujar 1 casilla (alej√°ndose del fueguito)
                if(dir.dx !== 0 || dir.dy !== 0) {
                    const pushX = target.x + dir.dx;
                    const pushY = target.y + dir.dy;
                    if(pushX >= 0 && pushX < SIZE && pushY >= 0 && pushY < SIZE &&
                       map[pushY][pushX] === 0 && !getEntityAt(pushX, pushY)) {
                        target.x = pushX;
                        target.y = pushY;
                        log(`${target.name} es empujado por la explosi√≥n!`, 'log-dmg');
                    } else {
                        // Colisi√≥n
                        const collisionDmg = 150000;
                        applyDamage(target, collisionDmg, "Colisi√≥n por explosi√≥n", {name: 'üî• Fueguito', id: 'FUEGO'});
                    }
                }
            }
        });

        // Efecto visual
        const cellEl = document.querySelector(`#grid .cell:nth-child(${fuego.y * SIZE + fuego.x + 1})`);
        if(cellEl) {
            cellEl.classList.add('on-fire');
            setTimeout(() => cellEl.classList.remove('on-fire'), 500);
        }
    });

    draw();
}

function startEnemyTurn() {
    enemyTurnActive = true; resetActions();
    const config = levelConfig[currentLevel];

    if(config.isBoss) {
        log("üëø Turno de La Diabla... ¬°Prep√°rense!");
    } else {
        log("Turno de los Escotes... ¬°Cerrando cuentas!");
    }
    draw();

    setTimeout(() => {
        // Primero: hacer explotar fueguitos
        processFueguitos();

        // Copiar array para evitar problemas si se elimina un Escote durante la iteraci√≥n
        const activeEnemies = enemies.filter(e => e.hp > 0);
        activeEnemies.forEach(e => {
            // Si es la Diabla, usar IA especial
            if(e.isBoss) {
                actDiabla(e);
                return;
            }
            if(e.hp <= 0) return; // Verificar de nuevo por si muri√≥
            const alivePlayers = players.filter(pl => pl.hp > 0);
            if(alivePlayers.length === 0) return;

            // IA mejorada: seleccionar objetivo
            let target = null;

            // 1. Buscar jugador con poca vida (menos del 30%) que est√© al alcance (distancia <= 4)
            const lowHpPlayers = alivePlayers.filter(pl => {
                const hpPercent = pl.hp / pl.maxHp;
                const dist = Math.abs(e.x - pl.x) + Math.abs(e.y - pl.y);
                return hpPercent < 0.30 && dist <= 4;
            });

            if(lowHpPlayers.length > 0) {
                // Priorizar el de menor HP
                target = lowHpPlayers.reduce((a, b) => a.hp < b.hp ? a : b);
                log(`${e.name} detecta a ${target.name} debilitado!`, 'log-dmg');
            }

            // 2. Si no hay objetivo d√©bil, priorizar El Joven si est√° cerca
            if(!target) {
                const elJoven = alivePlayers.find(pl => pl.id === 'K');
                if(elJoven && Math.abs(e.x - elJoven.x) + Math.abs(e.y - elJoven.y) <= 4) {
                    target = elJoven;
                }
            }

            // 3. Si no, atacar al m√°s cercano
            if(!target) {
                target = alivePlayers.reduce((closest, pl) => {
                    const distCurrent = Math.abs(e.x - pl.x) + Math.abs(e.y - pl.y);
                    const distClosest = Math.abs(e.x - closest.x) + Math.abs(e.y - closest.y);
                    return distCurrent < distClosest ? pl : closest;
                });
            }

            if(!target) return;

            // Movimiento hacia el objetivo - priorizar cuerpo a cuerpo
            let movedThisTurn = false;
            for(let i=0; i<e.pm; i++) {
                const currentDist = Math.abs(e.x-target.x)+Math.abs(e.y-target.y);
                if(currentDist <= 1) break; // Ya est√° adyacente

                let reach = calculateReach(e.x, e.y, 1);
                let best = null;
                let bestDist = currentDist;

                for(let key of reach.keys()) {
                    let [nx, ny] = key.split(',').map(Number);
                    let d = Math.abs(nx-target.x)+Math.abs(ny-target.y);
                    if(d < bestDist) {
                        best = {x:nx, y:ny};
                        bestDist = d;
                    }
                }

                // Si encontr√≥ mejor posici√≥n, moverse
                if(best) {
                    e.x = best.x;
                    e.y = best.y;
                    movedThisTurn = true;
                } else {
                    // No puede acercarse m√°s, intentar rodear obst√°culos
                    // Buscar cualquier casilla que no sea la actual
                    for(let key of reach.keys()) {
                        let [nx, ny] = key.split(',').map(Number);
                        if(nx !== e.x || ny !== e.y) {
                            e.x = nx; e.y = ny;
                            movedThisTurn = true;
                            break;
                        }
                    }
                    if(!movedThisTurn) break; // Completamente bloqueado
                }
            }

            // DESPU√âS de moverse: reconsiderar objetivo para "Hola perdido!"
            // Buscar si hay alguien adyacente con poca vida que sea mejor objetivo
            const adjacentPlayers = alivePlayers.filter(pl =>
                Math.abs(e.x - pl.x) + Math.abs(e.y - pl.y) <= 1
            );

            if(adjacentPlayers.length > 0) {
                // Priorizar al de menor HP entre los adyacentes
                const weakestAdjacent = adjacentPlayers.reduce((a, b) => a.hp < b.hp ? a : b);
                // Si el m√°s d√©bil adyacente tiene menos HP que el objetivo actual, cambiar
                if(weakestAdjacent.hp < target.hp || Math.abs(e.x - target.x) + Math.abs(e.y - target.y) > 1) {
                    target = weakestAdjacent;
                }
            }

            // Calcular distancia al objetivo final
            const distToTarget = Math.abs(e.x-target.x)+Math.abs(e.y-target.y);
            const config = levelConfig[currentLevel];

            // PRIORIDAD: "Hola perdido!" (cuerpo a cuerpo) - siempre intentar primero
            if(distToTarget <= 1) {
                const baseDmg = config.baseDmgMin + Math.random() * (config.baseDmgMax - config.baseDmgMin);
                applyDamage(target, baseDmg, "Hola perdido!", e);
                // 30% probabilidad de quitar 1 PA para el pr√≥ximo turno
                if(Math.random() < 0.3) {
                    target.paPenalty = (target.paPenalty || 0) + 1;
                    log(`${e.name} confunde a ${target.name}: -1 PA pr√≥ximo turno!`, 'log-dmg');
                }
            }
            // SECUNDARIO: "Ya no saludas" (distancia) - solo si no alcanza con Hola perdido
            // Hace da√±o bajo (16490-22150) + debuff + atrae si est√° en l√≠nea recta
            else if(distToTarget <= 4) {
                const lowDmg = 16490 + Math.random() * (22150 - 16490);
                applyDamage(target, lowDmg, "Ya no saludas", e);

                // Si est√° en l√≠nea recta (misma fila o columna), atraer 1 casilla
                if(e.x === target.x || e.y === target.y) {
                    const dx = Math.sign(e.x - target.x); // Direcci√≥n hacia el Escote
                    const dy = Math.sign(e.y - target.y);
                    const newX = target.x + dx;
                    const newY = target.y + dy;
                    // Verificar que la casilla destino est√© libre
                    if(newX >= 0 && newX < SIZE && newY >= 0 && newY < SIZE &&
                       map[newY][newX] === 0 && !getEntityAt(newX, newY)) {
                        target.x = newX;
                        target.y = newY;
                        log(`${e.name} atrae a ${target.name} 1 casilla!`, 'log-dmg');
                    }
                }

                // Puede: quitar 1 PM (35%), quitar 1 PA (35%), o nada (30%)
                const roll = Math.random();
                if(roll < 0.35) {
                    target.pmPenalty = (target.pmPenalty || 0) + 1;
                    log(`${target.name} queda paralizado: -1 PM pr√≥ximo turno!`, 'log-dmg');
                } else if(roll < 0.70) {
                    target.paPenalty = (target.paPenalty || 0) + 1;
                    log(`${target.name} queda confundido: -1 PA pr√≥ximo turno!`, 'log-dmg');
                } else {
                    log(`${target.name} ignora el efecto secundario.`);
                }
            }
        });

        if(uva) actUva();

        if(players.find(pl=>pl.id==='K').hp > 0) {
            // Reset PA/PM y aplicar penalizaciones pendientes de este turno
            players.forEach(pl => {
                if(pl.hp > 0) {
                    // Aplicar penalizaciones de Escotes (guardadas durante el turno)
                    const paPenalty = pl.paPenalty || 0;
                    const pmPenalty = pl.pmPenalty || 0;
                    // Sumar bonus de Uva (si los tiene)
                    const paBonus = pl.paBonus || 0;
                    const pmBonus = pl.pmBonus || 0;
                    pl.pa = Math.max(0, 6 - paPenalty + paBonus);
                    pl.pm = Math.max(0, 3 - pmPenalty + pmBonus);
                    // Limpiar penalizaciones y bonificaciones (solo duran 1 turno)
                    delete pl.paPenalty;
                    delete pl.pmPenalty;
                    delete pl.paBonus;
                    delete pl.pmBonus;
                }
            });

            // === AURA PROTECTORA DE H ===
            // Si alg√∫n aliado tiene <35% HP, H otorga +30% resistencia a aliados adyacentes
            const hPlayer = players.find(pl => pl.id === 'H' && pl.hp > 0);
            const anyAllyLow = players.some(ally => ally.hp > 0 && (ally.hp / ally.maxHp) < 0.35);
            if(hPlayer && anyAllyLow) {
                const adjacentAllies = players.filter(ally =>
                    ally.hp > 0 &&
                    ally.id !== 'H' &&
                    Math.abs(ally.x - hPlayer.x) + Math.abs(ally.y - hPlayer.y) === 1
                );
                if(adjacentAllies.length > 0) {
                    adjacentAllies.forEach(ally => {
                        addEffect(ally, 'resistance', 0.30, 1);
                    });
                    log(`üõ°Ô∏è ¬°AURA PROTECTORA de H! +30% resistencia a ${adjacentAllies.map(a => a.name).join(', ')} por 1 turno`, 'log-heal');
                }
            }

            processEffects(); // Procesar efectos temporales (reducir duraci√≥n)
            comboTracker = {}; // Resetear tracker de combos
            enemyTurnActive = false; log("Tu turno Jovenes."); draw();
        }
    }, 1000);
}

// Comandar a Uva para atacar enemigo o boostear aliado
function commandUva(target) {
    if(!uva) return;

    const joven = players.find(pl => pl.id === 'K');
    const isEvolved = joven && (joven.hp / joven.maxHp) < 0.30;
    const isEnemy = isEnemyEntity(target);
    const isAlly = players.includes(target);

    // Si Uva est√° evolucionada y el objetivo es un aliado, no hacer nada
    if(isEvolved && isAlly) {
        log(`‚ö° Uva EVOLUCIONADA ignora a ${target.name}. Solo ataca enemigos!`, 'log-dmg');
        return;
    }

    // Uva se mueve hacia el objetivo
    const uvaName = isEvolved ? 'Uva ‚ö°üê∂‚ö°' : 'Uva üê∂';
    log(`${players[activeIdx].name} le ordena a ${uvaName} ir hacia ${target.name}!`);

    // Mover Uva hacia el objetivo (hasta 5 PM)
    for (let i = 0; i < 5; i++) {
        if (Math.abs(uva.x - target.x) + Math.abs(uva.y - target.y) <= 1) break;
        let reach = calculateReach(uva.x, uva.y, 1);
        let best = { x: uva.x, y: uva.y, d: 999 };
        for (let key of reach.keys()) {
            let [nx, ny] = key.split(',').map(Number);
            let d = Math.abs(nx - target.x) + Math.abs(ny - target.y);
            if (d < best.d) best = { x: nx, y: ny, d: d };
        }
        uva.x = best.x; uva.y = best.y;
    }

    // Verificar si lleg√≥ al objetivo
    if (Math.abs(uva.x - target.x) + Math.abs(uva.y - target.y) > 1) {
        log(`${uvaName} no alcanz√≥ a ${target.name}. Est√° muy lejos.`);
        return;
    }

    // Uva evolucionada: nunca falla, siempre ataca
    if(!isEvolved) {
        // 40% de probabilidad de que Uva no quiera hacer nada
        if (Math.random() < 0.4) {
            log(`${uvaName} mira a ${target.name} y bosteza. No le da la gana.`);
            return;
        }
    }

    if (isEnemy) {
        if(isEvolved) {
            // UVA EVOLUCIONADA: Ataque especial en cruz + empuja + quita 3PM
            log(`‚ö° ¬°UVA EVOLUCIONADA ATACA!`, 'log-dmg');

            // Empujar 1 casilla
            const dx = Math.sign(target.x - uva.x);
            const dy = Math.sign(target.y - uva.y);
            const pushX = target.x + dx;
            const pushY = target.y + dy;
            if(pushX >= 0 && pushX < SIZE && pushY >= 0 && pushY < SIZE &&
               map[pushY][pushX] === 0 && !getEntityAt(pushX, pushY)) {
                target.x = pushX;
                target.y = pushY;
                log(`${uvaName} empuja a ${target.name} 1 casilla!`, 'log-dmg');
            }

            // Quitar 3 PM fijos
            target.pm = Math.max(0, target.pm - 3);
            log(`${uvaName} paraliza a ${target.name}: -3 PM!`, 'log-dmg');

            // Ataque en zona en cruz (alcance 3 cardinales)
            // Patr√≥n:    X
            //          X O X
            //            X
            const crossPositions = [
                {x: uva.x, y: uva.y - 1}, {x: uva.x, y: uva.y - 2}, {x: uva.x, y: uva.y - 3}, // Arriba
                {x: uva.x, y: uva.y + 1}, {x: uva.x, y: uva.y + 2}, {x: uva.x, y: uva.y + 3}, // Abajo
                {x: uva.x - 1, y: uva.y}, {x: uva.x - 2, y: uva.y}, {x: uva.x - 3, y: uva.y}, // Izquierda
                {x: uva.x + 1, y: uva.y}, {x: uva.x + 2, y: uva.y}, {x: uva.x + 3, y: uva.y}  // Derecha
            ];

            const zoneDmg = 400000 + Math.random() * 200000;
            let hitCount = 0;
            enemies.forEach(e => {
                if(e.hp > 0 && crossPositions.some(pos => pos.x === e.x && pos.y === e.y)) {
                    e.hp -= zoneDmg;
                    log(`‚ö° ${uvaName} a√∫lla y ${e.name} recibe ${fmt(zoneDmg)} en zona!`, 'log-dmg');
                    hitCount++;
                    if(e.hp <= 0) {
                        e.hp = 0;
                        log(`${e.name} fue liquidado por el aullido!`);
                    }
                }
            });
            if(hitCount > 0) {
                AudioManager.playSFX('critico');
            }

            // Limpiar enemigos muertos
            enemies = enemies.filter(e => e.hp > 0);
            if(enemies.length === 0) endGame("¬°VICTORIA!", "Escotes eliminados. Capital a salvo.", true);

        } else {
            // Atacar enemigo (Uva normal)
            const effect = Math.floor(Math.random() * 4);
            switch(effect) {
                case 0: // Mordida normal
                    const dmg = 500000 + Math.random() * 300000;
                    applyDamage(target, dmg, "Mordida üê∂", uva);
                    break;
                case 1: // -2 PA
                    target.pa = Math.max(0, target.pa - 2);
                    log(`Uva üê∂ muerde a ${target.name}: -2 PA!`, 'log-dmg');
                    break;
                case 2: // Vulnerabilidad
                    addEffect(target, 'vulnerability', 0.3, 2);
                    log(`Uva üê∂ intimida a ${target.name}: ¬°+30% da√±o recibido por 2 turnos!`, 'log-dmg');
                    break;
                case 3: // -1 PM
                    target.pm = Math.max(0, target.pm - 1);
                    log(`Uva üê∂ se interpone ante ${target.name}: -1 PM!`, 'log-dmg');
                    break;
            }
        }
    } else if (isAlly && !isEvolved) {
        // Boostear aliado (solo Uva normal)
        const effect = Math.floor(Math.random() * 4);
        switch(effect) {
            case 0: // +3 PA
                target.pa += 3;
                log(`Uva üê∂ inspira a ${target.name}: +3 PA!`, 'log-heal');
                break;
            case 1: // +2 PM
                target.pm += 2;
                log(`Uva üê∂ empuja a ${target.name}: +2 PM!`, 'log-heal');
                break;
            case 2: // +50% da√±o
                addEffect(target, 'dmgBoost', 0.5, 2);
                log(`Uva üê∂ gru√±e junto a ${target.name}: ¬°+50% da√±o por 2 turnos!`, 'log-heal');
                break;
            case 3: // +30% resistencia
                addEffect(target, 'resistance', 0.3, 2);
                log(`Uva üê∂ protege a ${target.name}: ¬°+30% resistencia por 2 turnos!`, 'log-heal');
                break;
        }
    }
}

function actUva() {
    // Uva se mueve libremente (5 PM)
    const allTargets = [...players.filter(pl => pl.hp > 0), ...enemies.filter(e => e.hp > 0)];
    const randomTarget = allTargets[Math.floor(Math.random() * allTargets.length)];

    // Movimiento ca√≥tico (5 PM)
    for (let i = 0; i < 5; i++) {
        if (Math.abs(uva.x - randomTarget.x) + Math.abs(uva.y - randomTarget.y) <= 1) break;
        let reach = calculateReach(uva.x, uva.y, 1);
        let best = { x: uva.x, y: uva.y, d: 999 };
        for (let key of reach.keys()) {
            let [nx, ny] = key.split(',').map(Number);
            let d = Math.abs(nx - randomTarget.x) + Math.abs(ny - randomTarget.y);
            if (d < best.d) best = { x: nx, y: ny, d: d };
        }
        uva.x = best.x; uva.y = best.y;
    }

    // Buscar objetivo adyacente
    const adjacent = allTargets.filter(t => Math.abs(uva.x - t.x) + Math.abs(uva.y - t.y) <= 1);
    if (adjacent.length === 0) {
        log("Uva üê∂ mira al vac√≠o y ladra... nada pasa.");
        return;
    }

    const target = adjacent[Math.floor(Math.random() * adjacent.length)];
    const isEnemy = isEnemyEntity(target);

    // MORDIDA INSTAKILL - muy rara (5% probabilidad, solo a enemigos)
    if (isEnemy && Math.random() < 0.05) {
        log(`ü¶∑ ¬°¬°¬°UVA üê∂ USA MORDIDA LETAL!!!`, 'log-dmg');
        log(`${target.name} fue ELIMINADO INSTANT√ÅNEAMENTE!`, 'log-dmg');
        target.hp = 0;
        enemies = enemies.filter(e => e.hp > 0);
        if(enemies.length === 0) endGame("¬°VICTORIA!", "Escotes eliminados. Capital a salvo.", true);
        return;
    }

    const effect = Math.floor(Math.random() * 6);

    if (isEnemy) {
        // EFECTOS NEGATIVOS para enemigos
        switch(effect) {
            case 0: // -2 PA
                target.pa = Math.max(0, target.pa - 2);
                log(`Uva üê∂ muerde a ${target.name}: -2 PA!`, 'log-dmg');
                break;
            case 1: // -1 PM
                target.pm = Math.max(0, target.pm - 1);
                log(`Uva üê∂ se interpone ante ${target.name}: -1 PM!`, 'log-dmg');
                break;
            case 2: // Vulnerabilidad (debuff temporal 2 turnos)
                addEffect(target, 'vulnerability', 0.3, 2);
                log(`Uva üê∂ intimida a ${target.name}: ¬°+30% da√±o recibido por 2 turnos!`, 'log-dmg');
                break;
            case 3: // Reducir resistencia
                if(target.resistance) {
                    target.resistance = Math.max(0, target.resistance - 0.1);
                    log(`Uva üê∂ debilita a ${target.name}: -10% resistencia!`, 'log-dmg');
                } else {
                    addEffect(target, 'vulnerability', 0.15, 2);
                    log(`Uva üê∂ gru√±e a ${target.name}: ¬°+15% da√±o recibido por 2 turnos!`, 'log-dmg');
                }
                break;
            case 4: // Nada - se distrae
                log("Uva üê∂ se rasca una oreja. No pasa nada.");
                break;
            case 5: // Nada - no quiere
                log(`Uva üê∂ mira a ${target.name} y bosteza. No le da la gana.`);
                break;
        }
    } else {
        // EFECTOS POSITIVOS para aliados
        switch(effect) {
            case 0: // +3 PA (como bonus para pr√≥ximo turno)
                target.paBonus = (target.paBonus || 0) + 3;
                log(`Uva üê∂ inspira a ${target.name}: +3 PA pr√≥ximo turno!`, 'log-heal');
                break;
            case 1: // +2 PM (como bonus para pr√≥ximo turno)
                target.pmBonus = (target.pmBonus || 0) + 2;
                log(`Uva üê∂ empuja a ${target.name}: +2 PM pr√≥ximo turno!`, 'log-heal');
                break;
            case 2: // Aumentar da√±o (buff temporal 2 turnos)
                addEffect(target, 'dmgBoost', 0.5, 2);
                log(`Uva üê∂ gru√±e junto a ${target.name}: ¬°+50% da√±o por 2 turnos!`, 'log-heal');
                break;
            case 3: // Aumentar resistencia (buff temporal 2 turnos)
                addEffect(target, 'resistance', 0.3, 2);
                log(`Uva üê∂ protege a ${target.name}: ¬°+30% resistencia por 2 turnos!`, 'log-heal');
                break;
            case 4: // Nada - se distrae
                log("Uva üê∂ se rasca una oreja. No pasa nada.");
                break;
            case 5: // Nada - no quiere
                log(`Uva üê∂ mira a ${target.name} y bosteza. No le da la gana.`);
                break;
        }
    }
}

function log(msg, cl='') {
    const l = document.getElementById('log');
    const d = document.createElement('div'); d.className = cl; d.textContent = "> " + msg;
    l.prepend(d);
}

// ===== SISTEMA DE EFECTOS TEMPORALES =====
function addEffect(target, type, value, turns = 2) {
    activeEffects.push({ targetId: target.id, type, value, turnsLeft: turns });
    // Aplicar el efecto inmediatamente
    if(type === 'dmgBoost') target.dmgBoost = (target.dmgBoost || 0) + value;
    if(type === 'resistance') target.resistance = (target.resistance || 0) + value;
    if(type === 'vulnerability') target.vulnerability = (target.vulnerability || 0) + value;
    if(type === 'paBonus') target.paBonus = (target.paBonus || 0) + value;
}

function processEffects() {
    // Decrementar turnos y eliminar efectos expirados
    activeEffects = activeEffects.filter(eff => {
        eff.turnsLeft--;
        if(eff.turnsLeft <= 0) {
            // Encontrar el target y remover el efecto
            const target = [...players, ...enemies, uva].find(t => t && t.id === eff.targetId);
            if(target) {
                if(eff.type === 'dmgBoost') {
                    target.dmgBoost = (target.dmgBoost || 0) - eff.value;
                    if(target.dmgBoost <= 0) delete target.dmgBoost;
                    log(`El buff de da√±o de ${target.name} ha expirado.`);
                }
                if(eff.type === 'resistance') {
                    target.resistance = (target.resistance || 0) - eff.value;
                    if(target.resistance <= 0) delete target.resistance;
                    log(`El buff de resistencia de ${target.name} ha expirado.`);
                }
                if(eff.type === 'vulnerability') {
                    target.vulnerability = (target.vulnerability || 0) - eff.value;
                    if(target.vulnerability <= 0) delete target.vulnerability;
                    log(`La debilidad de ${target.name} ha expirado.`);
                }
                if(eff.type === 'paBonus') {
                    target.paBonus = (target.paBonus || 0) - eff.value;
                    if(target.paBonus <= 0) delete target.paBonus;
                    log(`El bonus de PA de ${target.name} ha expirado.`);
                }
            }
            return false; // Eliminar de la lista
        }
        return true; // Mantener en la lista
    });
}

function endGame(title, msg, isVictory = false) {
    const overlay = document.getElementById('end-overlay');
    const titleEl = document.getElementById('end-title');
    const msgEl = document.getElementById('end-msg');
    const btnContainer = document.getElementById('end-buttons');

    // Detener m√∫sica y reproducir sonido de victoria/derrota
    AudioManager.stopMusic();
    AudioManager.playSFX(isVictory ? 'victoria' : 'derrota');

    titleEl.textContent = title;

    if(isVictory && currentLevel < MAX_LEVEL) {
        // Victoria pero no es el √∫ltimo nivel
        const reward = levelConfig[currentLevel].reward;
        msgEl.innerHTML = `${msg}<br><br>
            <span style="color:#4dff4d;">¬°RECOMPENSA: +${fmt(reward)} para cada h√©roe!</span><br>
            <span style="color:#f39c12;">Siguiente: Nivel ${currentLevel + 1}</span>`;
        btnContainer.innerHTML = `
            <button onclick="nextLevel()" style="padding:10px 25px; cursor:pointer; background:#2ecc71; color:white; border:none; font-weight:bold; border-radius:5px; margin-right:10px;">SIGUIENTE NIVEL</button>
            <button onclick="location.reload()" style="padding:10px 25px; cursor:pointer; background:#e74c3c; color:white; border:none; font-weight:bold; border-radius:5px;">REINICIAR</button>
        `;
    } else if(isVictory && currentLevel === MAX_LEVEL) {
        // Victoria final
        const reward = levelConfig[currentLevel].reward;
        msgEl.innerHTML = `${msg}<br><br>
            <span style="color:#f39c12; font-size:18px;">¬°COMPLETASTE TODOS LOS NIVELES!</span><br>
            <span style="color:#4dff4d;">Recompensa final: +${fmt(reward)}</span>`;
        btnContainer.innerHTML = `
            <button onclick="location.reload()" style="padding:10px 25px; cursor:pointer; background:#f39c12; color:black; border:none; font-weight:bold; border-radius:5px;">JUGAR DE NUEVO</button>
        `;
    } else {
        // Derrota - mostrar resumen del combate
        const aliveEnemies = enemies.filter(e => e.hp > 0);
        const alivePlayers = players.filter(p => p.hp > 0);
        let summary = `<br><br><span style="color:#aaa; font-size:12px;">`;
        summary += `Enemigos restantes: ${aliveEnemies.length}<br>`;
        summary += `Aliados en pie: ${alivePlayers.length}/3<br>`;
        summary += `Nivel alcanzado: ${currentLevel}/${MAX_LEVEL}`;
        summary += `</span>`;
        msgEl.innerHTML = msg + summary;
        btnContainer.innerHTML = `
            <button onclick="location.reload()" style="padding:10px 25px; cursor:pointer; background:#f39c12; color:black; border:none; font-weight:bold; border-radius:5px;">REINTENTAR</button>
        `;
    }

    overlay.classList.remove('hidden');
}

function nextLevel() {
    // Dar recompensa
    const reward = levelConfig[currentLevel].reward;
    players.forEach(p => {
        p.hp = Math.min(p.maxHp, p.hp + reward);
        p.maxHp += reward; // Incremento permanente
    });

    // Avanzar nivel
    currentLevel++;
    document.getElementById('end-overlay').classList.add('hidden');
    document.getElementById('log').innerHTML = '';

    // Iniciar nuevo nivel (conservar HP actual)
    init(true);
}

// Funci√≥n para alternar mute
function toggleMute() {
    const muted = AudioManager.toggleMute();
    document.getElementById('muteBtn').textContent = muted ? 'üîá' : 'üîä';
}

init();
</script>
</body>
</html>